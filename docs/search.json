[{"path":"/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, interest fostering open welcoming community, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality. Examples unacceptable behavior participants include: use sexualized language imagery Personal attacks Trolling insulting/derogatory comments Public private harassment Publishing ’s private information, physical electronic addresses, without explicit permission unethical unprofessional conduct Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful. adopting Code Conduct, project maintainers commit fairly consistently applying principles every aspect managing project. Project maintainers follow enforce Code Conduct may permanently removed project team. Code Conduct applies within project spaces public spaces individual representing project community. Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project maintainer solymos@ualberta.ca. complaints reviewed investigated result response deemed necessary appropriate circumstances. Maintainers obligated maintain confidentiality regard reporter incident. Code Conduct adapted Contributor Covenant, version 1.3.0, available http://contributor-covenant.org/version/1/3/0/","code":""},{"path":"/articles/edma01-data.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"EDMA data","text":"EDMAinR R package Euclidean Distance Matrix Analysis (EDMA). EDMA coordinate‐free approach comparing biological shapes using landmark data. can install package GitHub help remotes R package: can now load EDMAinR package:","code":"if (!require(EDMAinR)) {   if (!require(remotes))       install.packages(\"remotes\")   remotes::install_github(\"psolymos/EDMAinR\") } library(EDMAinR) #> EDMAinR 0.2-0     2021-11-04"},{"path":[]},{"path":"/articles/edma01-data.html","id":"reading-data-from-xyz-files","dir":"Articles","previous_headings":"","what":"Reading data from xyz files","title":"EDMA data","text":"Use read_xyz function read 2D 3D landmark data *.xyz files. First specify paths two xyz files: Note: use system.file() function access example files package. defining files, either set working directory using setwd() use path like c:/Users/<user>/<etc>. xyz landmark data following structure: Header: description data. XYZ: indicates dimensions, XYZ means 3D landmark data. 42L 3 9: dimensions, e.g. 42 landmarks (\\(K\\)), 3 dimensions (\\(D\\)), 9 specimens (\\(n\\)). Landmark names, separated space. stacked data landmark coordinates, e.g. 3 columns, space separated numeric values \\(K \\times n\\) rows, \\(K\\) landmarks per individuals stacked \\(n\\) times. Blank line. Date scans specimen (\\(n\\) rows), part also used get specimen IDs. Now can read text files: Note: find information reading morphometrics file formats.","code":"file <- system.file(\"extdata/crouzon/Crouzon_P0_Global_MUT.xyz\",      package=\"EDMAinR\") x <- read_xyz(file) x #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 3 dimensions, 28 specimens"},{"path":"/articles/edma01-data.html","id":"the-edma-data-format","dir":"Articles","previous_headings":"","what":"The EDMA data format","title":"EDMA data","text":"printout x told us important facts data: header information dimensions. EDMA data object (class ‘edma_data’) list two elements: $name data set name (header information .xyz file), $data list \\(n\\) matrices (list can named specimen information present), matrix dimension \\(K \\times D\\), dimension names matrices describing landmark names (rows) coordinate names (columns).","code":""},{"path":"/articles/edma01-data.html","id":"edma-data-dimensions-and-names","dir":"Articles","previous_headings":"","what":"EDMA data dimensions and names","title":"EDMA data","text":"following methods used retrieve useful information EDMA data objects. Use dim access dimensions (landmarks, \\(K\\); dimensions, \\(D\\); replicates, \\(n\\)). landmarks, dimansions, specimens return landmark, dimension, specimen names, respectively, dimnames returns three list: dimension names missing input data file, use L denote landmarks S denote specimens. prepended numeric landmark specimen IDs. coordinate dimensions \"X\", \"Y\", optionally \"Z\" 3D landmark data. also possible manipulate dimension names. useful different files landmarks slight changes (lower/upper case differences, etc.):","code":"dim(x) # dimensions #> [1] 47  3 28 dimnames(x) # dimension names #> [[1]] #>  [1] \"amsph\" \"bas\"   \"cpsh\"  \"ethma\" \"ethmp\" \"laalf\" \"lasph\" \"lflac\" \"lnsla\" #> [10] \"lnslp\" \"locc\"  \"loci\"  \"lpalf\" \"lpfl\"  \"lpmx\"  \"lpns\"  \"lpsh\"  \"lpsq\"  #> [19] \"lpto\"  \"lptyp\" \"lsqu\"  \"lsyn\"  \"lzya\"  \"lzygo\" \"lzyt\"  \"opi\"   \"raalf\" #> [28] \"rasph\" \"rflac\" \"rmaxi\" \"rnsla\" \"rnslp\" \"rocc\"  \"roci\"  \"rpalf\" \"rpfl\"  #> [37] \"rpmx\"  \"rpns\"  \"rpsh\"  \"rpsq\"  \"rpto\"  \"rptyp\" \"rsqu\"  \"rsyn\"  \"rzya\"  #> [46] \"rzygo\" \"rzyt\"  #>  #> [[2]] #> [1] \"X\" \"Y\" \"Z\" #>  #> [[3]] #>  [1] \"CZCD1_1\"  \"CZCD1_2\"  \"CZCD1_7\"  \"CZCD1_10\" \"CZCD1_11\" \"CZCD1_15\" #>  [7] \"CZCD1_16\" \"CZCD1_18\" \"CZCD1_20\" \"CZCD1_21\" \"CZCD1_23\" \"CZCD1_24\" #> [13] \"CZCD1_25\" \"CZCD1_28\" \"CZCD1_30\" \"CZCD1_32\" \"CZCD1_36\" \"CZCD1_37\" #> [19] \"CZCD1_39\" \"CZCD1_40\" \"CZCD1_42\" \"CZCD1_53\" \"CZCD1_56\" \"CZCD1_59\" #> [25] \"CZCD1_65\" \"CZCD1_66\" \"CZCD1_72\" \"CZCD1_73\" landmarks(x) # landmark names #>  [1] \"amsph\" \"bas\"   \"cpsh\"  \"ethma\" \"ethmp\" \"laalf\" \"lasph\" \"lflac\" \"lnsla\" #> [10] \"lnslp\" \"locc\"  \"loci\"  \"lpalf\" \"lpfl\"  \"lpmx\"  \"lpns\"  \"lpsh\"  \"lpsq\"  #> [19] \"lpto\"  \"lptyp\" \"lsqu\"  \"lsyn\"  \"lzya\"  \"lzygo\" \"lzyt\"  \"opi\"   \"raalf\" #> [28] \"rasph\" \"rflac\" \"rmaxi\" \"rnsla\" \"rnslp\" \"rocc\"  \"roci\"  \"rpalf\" \"rpfl\"  #> [37] \"rpmx\"  \"rpns\"  \"rpsh\"  \"rpsq\"  \"rpto\"  \"rptyp\" \"rsqu\"  \"rsyn\"  \"rzya\"  #> [46] \"rzygo\" \"rzyt\" dimensions(x) # the names of the coordinate dimensions #> [1] \"X\" \"Y\" \"Z\" specimens(x) # specimen IDs #>  [1] \"CZCD1_1\"  \"CZCD1_2\"  \"CZCD1_7\"  \"CZCD1_10\" \"CZCD1_11\" \"CZCD1_15\" #>  [7] \"CZCD1_16\" \"CZCD1_18\" \"CZCD1_20\" \"CZCD1_21\" \"CZCD1_23\" \"CZCD1_24\" #> [13] \"CZCD1_25\" \"CZCD1_28\" \"CZCD1_30\" \"CZCD1_32\" \"CZCD1_36\" \"CZCD1_37\" #> [19] \"CZCD1_39\" \"CZCD1_40\" \"CZCD1_42\" \"CZCD1_53\" \"CZCD1_56\" \"CZCD1_59\" #> [25] \"CZCD1_65\" \"CZCD1_66\" \"CZCD1_72\" \"CZCD1_73\" lm <- landmarks(x) # copy original names landmarks(x) <- toupper(lm) landmarks(x) # new landmark names #>  [1] \"AMSPH\" \"BAS\"   \"CPSH\"  \"ETHMA\" \"ETHMP\" \"LAALF\" \"LASPH\" \"LFLAC\" \"LNSLA\" #> [10] \"LNSLP\" \"LOCC\"  \"LOCI\"  \"LPALF\" \"LPFL\"  \"LPMX\"  \"LPNS\"  \"LPSH\"  \"LPSQ\"  #> [19] \"LPTO\"  \"LPTYP\" \"LSQU\"  \"LSYN\"  \"LZYA\"  \"LZYGO\" \"LZYT\"  \"OPI\"   \"RAALF\" #> [28] \"RASPH\" \"RFLAC\" \"RMAXI\" \"RNSLA\" \"RNSLP\" \"ROCC\"  \"ROCI\"  \"RPALF\" \"RPFL\"  #> [37] \"RPMX\"  \"RPNS\"  \"RPSH\"  \"RPSQ\"  \"RPTO\"  \"RPTYP\" \"RSQU\"  \"RSYN\"  \"RZYA\"  #> [46] \"RZYGO\" \"RZYT\" landmarks(x) <- lm # reset names to original"},{"path":"/articles/edma01-data.html","id":"selecting-subsets-of-edma-data-objects","dir":"Articles","previous_headings":"","what":"Selecting subsets of EDMA data objects","title":"EDMA data","text":"Subsetting data comes handy sometimes, .e. might want select landmarks get simplified picture relationships, different input files list different landmarks want select ones present data set. need filter specimens, want select specimens certain ages, gender, etc. Often need draw random sample specimens (randomization bootstrap). general way subset data sets via [ function (.e. x[, j, k]), 3 indices inside brackets refer landmarks (), dimensions (j), specimens (k). Imagine data 3D data cube square brackets allow us slice cube 3 different directions. Read use square brackets extract parts data object: ?Extract (see section ‘Matrices arrays’). important thing keep mind empty index (e.g. x[,,]) means ‘select everything’. can take subsets using: numeric indices (like saw ), logical indices, character names. Logical indices might handy , e.g., ancillary data specimens. age specimens (values ages matching order specimens EDMA data object), can use x[,,age < 1]. Character based subsets useful want select homologous landmarks multiple objects, want make sure landmarks’ order identical among multiple objects. [ function can used take subset also reorder landmarks specimens. Character indices suitable purpose.","code":"x[1:10, , ]  # select the 1st 10 landmarks #> EDMA data: Crouzon P0 MUT #> 10 landmarks, 3 dimensions, 28 specimens x[ , 1:2, ]  # select 2 of the 2 dimensions #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 2 dimensions, 28 specimens x[ , , 11:20] # select individuals from 11 to 20 #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 3 dimensions, 10 specimens x[1:10, , 1:20] # combine multiple indices #> EDMA data: Crouzon P0 MUT #> 10 landmarks, 3 dimensions, 20 specimens"},{"path":"/articles/edma01-data.html","id":"coercing-edma-data-into-other-object-types","dir":"Articles","previous_headings":"","what":"Coercing EDMA data into other object types","title":"EDMA data","text":"data ($data) format inside object x list \\(K \\times D\\) matrices, one individual. Sometimes handy stack matrices create rectangular data (either matrix, data frame, \\(n \\times K\\) rows \\(D\\) columns): Note: using str show structure objects, necessary exploring data. str tells us dimensions (1316 rows 3 columns, first values, dimension names). Alternatively, can store data array (\\(K \\times D \\times n\\)):","code":"str(as.matrix(x)) #>  num [1:1316, 1:3] 5.85 2.79 6.86 9.11 8.25 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:1316] \"CZCD1_1_amsph\" \"CZCD1_1_bas\" \"CZCD1_1_cpsh\" \"CZCD1_1_ethma\" ... #>   ..$ : chr [1:3] \"X\" \"Y\" \"Z\" str(as.array(x)) #>  num [1:47, 1:3, 1:28] 5.85 2.79 6.86 9.11 8.25 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ : chr [1:47] \"amsph\" \"bas\" \"cpsh\" \"ethma\" ... #>   ..$ : chr [1:3] \"X\" \"Y\" \"Z\" #>   ..$ : chr [1:28] \"CZCD1_1\" \"CZCD1_2\" \"CZCD1_7\" \"CZCD1_10\" ..."},{"path":"/articles/edma01-data.html","id":"turning-3d-arrays-into-edma-data-objects","dir":"Articles","previous_headings":"","what":"Turning 3D arrays into EDMA data objects","title":"EDMA data","text":".edma_data function turns 3D array EDMA data object. useful handling 3D array objects returned many functions geomorph package (.e. reading Morphologika, NTS, TPS files). header information gets lost way, can set quite easily: Note: geomorph package needs installed separately using install.packages(\"geomorph\").","code":"xnew <- as.edma_data(as.array(x)) xnew #> EDMA data: Landmark data #> 47 landmarks, 3 dimensions, 28 specimens xnew$name <- \"This is the same data as before\" xnew #> EDMA data: This is the same data as before #> 47 landmarks, 3 dimensions, 28 specimens"},{"path":"/articles/edma01-data.html","id":"visual-inspection-of-the-data","dir":"Articles","previous_headings":"","what":"Visual inspection of the data","title":"EDMA data","text":"plot_2d function shows convex hulls confidence ellipses landmarks based specimens. plot showing first two axes multidimensional scaling based form matrices (\\(FM\\); pairwise Euclidean distances):  images default show convex hull landmark enclosing specimens. also possible use 95% confidence ellipses:","code":"plot_2d(x) plot_2d(x, hull=FALSE)"},{"path":"/articles/edma01-data.html","id":"spotting-data-errors","dir":"Articles","previous_headings":"","what":"Spotting data errors","title":"EDMA data","text":"Data sets can checked using plot function. default, function steps specimens check surprises. blue areas show convex hull landmark leaving single specimen , red dots show actual specimen. sign problem dot specimen located far outside convex hull. Using argument can specify specimen want display (possible select multiple specimen, use [ method take subset data plot plot_2d):  insert error show plot function can help identify problems. change coordinates 1st landmark 1st specimen. error showing outlier (long red line):","code":"plot(x, which=1) ## original values for specimen 1 plot(x, which=1) ## we change the 1st landmark xwrong <- x xwrong$data[[1]][1,1:2] <- c(2, 2) plot(xwrong, which=1)"},{"path":"/articles/edma01-data.html","id":"ordination-and-clustering","dir":"Articles","previous_headings":"","what":"Ordination and clustering","title":"EDMA data","text":"ordination plot shows specimens based multidimensional scaling using pairwise distances specimens. distances based T-statistic can calculated .dist(x). calculation involves following steps: calculate Euclidean distances (\\(ED_{}\\)) pairs landmarks specimen \\(\\) (\\(= 1, \\dots, n\\)) based coordinates, calculate Euclidean distances (\\(ED_{j}\\)) pairs landmarks specimen \\(j\\) (\\(j = 1, \\dots, n\\)) based coordinates, calculate ratio \\(ED_{} / ED_{j}\\), calculate T-statistic log scale (max/min ratio 1, 0 distance, becomes log(1)=0): \\(d_{ij}=log(max[ED_{} / ED_{j}] / min[ED_{} / ED_{j}])\\). multidimensional scaling uses square root transformed log-T distances. error shows nicely ordination plot (colored red):  cluster dendrogram based log-T distance matrix described . default agglomeration algorithm set Ward’s minimum variance method (\"ward.D2\") using square root log-T distances .  agglomeration methods can set passing different method argument, e.g. single linkage (see ?hclust list options):  ordination clustering functions return ordination/cluster results, plots can customized. example create plot  ggplot2 popular alternative R’s base graphics. create plots :  See ?ape::plot.phylo customize dendrograms:   ggdendro package can plot tree-like data structures ggplot2. example:","code":"plot_ord(x, col=c(2, rep(1, dim(x)[3]))) plot_ord(xwrong, col=c(\"red\", rep(\"black\", dim(xwrong)[3]))) plot_clust(x) plot_clust(xwrong) plot_clust(x, method = \"single\") plot_clust(xwrong, method = \"single\") mds <- plot_ord(x, plot=FALSE) str(mds) #> List of 5 #>  $ points: num [1:28, 1:2] -0.181 -0.757 -0.287 -0.116 -0.564 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:28] \"CZCD1_1\" \"CZCD1_2\" \"CZCD1_7\" \"CZCD1_10\" ... #>   .. ..$ : chr [1:2] \"Axis 1\" \"Axis 2\" #>  $ eig   : NULL #>  $ x     : NULL #>  $ ac    : num 0.143 #>  $ GOF   : num [1:2] 0.253 0.253 plot(mds$points, pch=4, col=\"darkgreen\",   main=\"Ordination diagram\") abline(h=0, v=0, lty=2, col=\"grey\") text(mds$points, labels=specimens(x), pos=1, cex=0.6, col=\"tan\") library(ggplot2) df <- as.data.frame(mds$points) p <- ggplot(data=df, aes(x=`Axis 1`, y=`Axis 2`, label=rownames(df))) +   geom_label() +   geom_vline(xintercept=0, lty=2) +   geom_hline(yintercept=0, lty=2) p h <- plot_clust(x, plot=FALSE) h #>  #> Call: #> hclust(d = d, method = method) #>  #> Cluster method   : ward.D2  #> Number of objects: 28 plot(h) plot(ape::as.phylo(h), type=\"cladogram\", font=1, cex=0.6) library(ggdendro) ggdendrogram(h, rotate = TRUE, size = 2)"},{"path":"/articles/edma01-data.html","id":"writing-data-to-xyz-format","dir":"Articles","previous_headings":"","what":"Writing data to xyz format","title":"EDMA data","text":"Different kinds morphometrics data formats can turned EDMA data format long can organized \\(K \\times D \\times n\\) array using .edma_data method. data EDMA data object, write_xyz function write text file extension xyz:","code":"f <- tempfile(fileext = \".xyz\") # create a temporary file write_xyz(x, file=f)            # write data to temp file tmp <- read_xyz(file=f)         # read back the data x                               # original data #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 3 dimensions, 28 specimens tmp                             # this should be the same too #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 3 dimensions, 28 specimens ## test if the all the dimnames are the same stopifnot(identical(dimnames(x), dimnames(tmp))) unlink(f)                       # delete temp file"},{"path":"/articles/edma02-form.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"EDMA form matrix","text":"tutorial explains use EDMAinR package fit nonparametric model landmark data estimate mean form. Let’s load package read example data set:","code":"library(EDMAinR) #> EDMAinR 0.2-0     2021-11-04 file <- system.file(\"extdata/crouzon/Crouzon_P0_Global_MUT.xyz\",      package=\"EDMAinR\") x <- read_xyz(file)"},{"path":"/articles/edma02-form.html","id":"nonparametric-fit","dir":"Articles","previous_headings":"","what":"Nonparametric fit","title":"EDMA form matrix","text":"use edma_fit function run nonparametric estimation. B argument number bootstrap replicates take (resampling \\(n\\) specimens object x replacement). chose small number , B ideally much higher (.e. B=99): nonparametric estimator gives mean form matrix (\\(\\hat{M}\\)) \\(\\hat{\\Sigma}_{K}^\\ast\\). can extract fitted model object (fit) using Meanform SigmaKstar functions: Note: using str function peek - otherwise huge - objects, just printing structure.","code":"fit <- edma_fit(x, B=9) fit #> EDMA nonparametric fit: Crouzon P0 MUT #> Call: edma_fit(x = x, B = 9) #> 47 landmarks, 3 dimensions, 28 specimens, 9 bootstrap runs str(Meanform(fit)) #>  num [1:47, 1:3] -0.734 -4.238 0.566 2.778 1.99 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:47] \"amsph\" \"bas\" \"cpsh\" \"ethma\" ... #>   ..$ : chr [1:3] \"X\" \"Y\" \"Z\" str(SigmaKstar(fit)) #>  num [1:47, 1:47] 0.000892 0.001559 -0.001256 -0.003276 -0.000797 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:47] \"amsph\" \"bas\" \"cpsh\" \"ethma\" ... #>   ..$ : chr [1:47] \"amsph\" \"bas\" \"cpsh\" \"ethma\" ..."},{"path":"/articles/edma02-form.html","id":"form-matrix","dir":"Articles","previous_headings":"","what":"Form matrix","title":"EDMA form matrix","text":"can extract stacked Euclidean distances (stacked form matrix \\(FM\\)) get_fm function. functions allows sort table based decreasing increasing order distance: columns row col refer landmark pairs. dist gives Euclidean distance mean form corrdinates two landmarks. lower upper indicates 95% confidence limits based bootstrap distribution pairwise distances (B replicates). confidence level can changed get_fm(fit, level=0.9).","code":"head(get_fm(fit)) #>     row   col     dist    lower    upper #> 1   bas amsph 3.577936 3.544238 3.593006 #> 2  cpsh amsph 1.540089 1.516862 1.547644 #> 3 ethma amsph 3.581924 3.532572 3.594558 #> 4 ethmp amsph 2.836499 2.809761 2.843809 #> 5 laalf amsph 4.422629 4.364985 4.438057 #> 6 lasph amsph 1.703182 1.692038 1.706379 head(get_fm(fit, sort=TRUE, decreasing=TRUE)) #>       row   col     dist    lower    upper #> 357   opi lnsla 10.51996 10.43197 10.57448 #> 855 rnsla   opi 10.51282 10.43827 10.56389 #> 364  rocc lnsla 10.50282 10.40954 10.56432 #> 435 rnsla  locc 10.50211 10.42761 10.54708 #> 342  locc lnsla 10.48118 10.39447 10.52831 #> 947  rocc rnsla 10.47022 10.39028 10.52702 head(get_fm(fit, sort=TRUE, decreasing=FALSE)) #>       row   col      dist     lower     upper #> 400 rnslp lnslp 0.1438078 0.1397477 0.1495684 #> 362 rnsla lnsla 0.2240747 0.2180288 0.2364729 #> 416  loci  locc 0.5006441 0.4911260 0.5183610 #> 977  roci  rocc 0.5033859 0.4838637 0.5265118 #> 127  rpsh  cpsh 0.5262757 0.5117248 0.5335223 #> 105  lpsh  cpsh 0.5750350 0.5637268 0.5836379"},{"path":"/articles/edma02-form.html","id":"visualizing-the-mean-form","dir":"Articles","previous_headings":"","what":"Visualizing the mean form","title":"EDMA form matrix","text":"2D plot gives projection mean form using multidimensional scaling (uses \\(FM\\) based \\(\\hat{M}\\)). dot size proportional SigmaKstar(fit) diagonal elements (scaling can chosen cex argument). plot_2d function returns plotting coordinates, can used add landmark names:  See ?rgl::plot3d options modify 3D plot.","code":"xy <- plot_2d(fit, cex=2) text(xy, labels=rownames(xy), pos=1) library(rgl) xyz <- plot_3d(fit) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/articles/edma02-form.html","id":"changing-the-default-colors","dir":"Articles","previous_headings":"","what":"Changing the default colors","title":"EDMA form matrix","text":"possible supply color values plot_2d plot_3d functions allow full control:  easier way, however, provide color palette choices listed help page function ?hcl.colors. available diverging color palettes : EDMAinR default palettes stored ‘options’. default palettes produces colors:  change default palette: produces following palettes:   Note: using ‘high’ end palette dots scaled standard deviation like measure based sqrt(diag(SigmaKstar(fit))). can reset defaults using op list saved :","code":"col <- rainbow(nrow(xy)) plot_2d(fit, col=col, cex=2) plot_3d(fit, col=col) rglwidget(width = 600, height = 600, reuse = FALSE) hcl.pals(type = \"diverging\") #>  [1] \"Blue-Red\"      \"Blue-Red 2\"    \"Blue-Red 3\"    \"Red-Green\"     #>  [5] \"Purple-Green\"  \"Purple-Brown\"  \"Green-Brown\"   \"Blue-Yellow 2\" #>  [9] \"Blue-Yellow 3\" \"Green-Orange\"  \"Cyan-Magenta\"  \"Tropic\"        #> [13] \"Broc\"          \"Cork\"          \"Vik\"           \"Berlin\"        #> [17] \"Lisbon\"        \"Tofino\" getOption(\"edma_options\") #> $diverging #> [1] \"Blue-Red\" #>  #> $qualitative #> [1] \"Set 2\" plot_edma_colors(101) op <- options(\"edma_options\" = list(     diverging = \"Green-Orange\",     qualitative = \"Dark 2\")) op #> $edma_options #> $edma_options$diverging #> [1] \"Blue-Red\" #>  #> $edma_options$qualitative #> [1] \"Set 2\" plot_2d(fit, cex=2) plot_3d(fit) rglwidget(width = 600, height = 600, reuse = FALSE) options(op)"},{"path":"/articles/edma03-form-difference.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"EDMA form difference matrix","text":"tutorial explains calculate form difference based 2 EDMA data objects homologous landmarks. use 2 data sets: one without mutation responsible Crouzon syndrome:","code":"library(EDMAinR) #> EDMAinR 0.2-0     2021-11-04  file1 <- system.file(\"extdata/crouzon/Crouzon_P0_Global_MUT.xyz\",     package=\"EDMAinR\") x1 <- read_xyz(file1)  file2 <- system.file(\"extdata/crouzon/Crouzon_P0_Global_NON-MUT.xyz\",     package=\"EDMAinR\") x2 <- read_xyz(file2)"},{"path":"/articles/edma03-form-difference.html","id":"estimating-the-form-matrices","dir":"Articles","previous_headings":"","what":"Estimating the form matrices","title":"EDMA form difference matrix","text":"first estimate mean forms (bootstrap replicates necessary). Form matrices (\\(FM\\)) formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms objects \\(\\) \\(B\\).","code":"numerator <- edma_fit(x1, B=25) denominator <- edma_fit(x2, B=25)"},{"path":"/articles/edma03-form-difference.html","id":"form-difference","dir":"Articles","previous_headings":"","what":"Form difference","title":"EDMA form difference matrix","text":"Form difference (\\(FDM\\)) calculated ratio form matrices (\\(FM\\)) numerator denominator objects following Lele Richtsmeier (1992, 1995): \\(FDM(,B) = FM(B)/FM()\\). Bootstrap distribution based fixing reference \\(FM\\) taking ratio reference \\(FM\\) bootstrap \\(FM\\)s object. ref_denom argument can used control object reference (denominator default), B number replicates drawn distribution:","code":"fdm <- edma_fdm(numerator, denominator, B=25) fdm #> EDMA form difference matrix #> Call: edma_fdm(numerator = numerator, denominator = denominator, B = 25) #> 25 bootstrap runs (ref: denominator) #> Tobs = 1.5981, p < 2.22e-16"},{"path":"/articles/edma03-form-difference.html","id":"global-t-test","dir":"Articles","previous_headings":"","what":"Global T-test","title":"EDMA form difference matrix","text":"global T-test based pairwise distances \\(FM\\)s, taking max/min ratio distances. done B replicates, provides null distribution. Algorithm global testing follows (suppose population 1 ‘reference’ population): Resample \\(n_1\\) observations first sample compute \\(FM_1^*\\). Resample \\(n_2\\) observations first sample compute \\(FM_2^*\\). Compute \\(FDM^* = FM_2^* / FM_1^*\\) \\(T^* = max(FDM^*) / min(FDM^*)\\). Repeat three steps B times get p-value. global_test provides summary test, plot_Ttest helps visualize null distribution (histogram) observed T statistic (vertical line):","code":"global_test(fdm) #>  #>  Bootstrap based EDMA T-test #>  #> data:  form difference matrix #> Tobs-value = 1.5981, B = 25, p-value < 2.2e-16 plot_Ttest(fdm)"},{"path":"/articles/edma03-form-difference.html","id":"local-testing","dir":"Articles","previous_headings":"","what":"Local testing","title":"EDMA form difference matrix","text":"local testing done based confidence intervals using stacked \\(FDM\\)s bootstrap. Output structure similar output get_fm function, interpretation confidence intervals different due different nature bootstrap distribution. distribution characterizes \\(FDM\\) \\(FM\\). confidence level can changed level argument. algorithm confidence intervals elements FDM follows: Resample \\(n_1\\) observations first sample compute \\(FM_1^*\\). Resample \\(n_2\\) observations second sample compute \\(FM_2^*\\). Compute \\(FDM* = FM_2^* / FM_1^*\\). Repeat three steps B times get confidence intervals elements \\(FDM\\). Differences confidence limits indicate distances significantly deviate bootstrap based null expectation, thus related landmarks drive differences. Inspecting highest lowest differences (using sort) can help revealing landmarks. lower upper limits confidence intervals based confint (row names indicate unsorted sequence landmark pairs output get_fdm(fdm)): plot_ci function shows pairwise differences confidence intervals. x-axis label shows landmark pairs, gets really busy. Use xshow=FALSE argument remove labels.  can use stacked \\(FDM\\) data frame make ggplot2 based plot:  ggplot2 version plot, can load plotly package make object interactive:","code":"head(get_fdm(fdm)) #>     row   col      dist     lower     upper #> 1   bas amsph 1.0425379 1.0291234 1.0572437 #> 2  cpsh amsph 0.9823765 0.9616780 0.9988809 #> 3 ethma amsph 1.0037761 0.9914403 1.0156289 #> 4 ethmp amsph 0.9401242 0.9278436 0.9510568 #> 5 laalf amsph 0.9878983 0.9788081 0.9990751 #> 6 lasph amsph 1.0161844 0.9891307 1.0317053 head(get_fdm(fdm, sort=TRUE, decreasing=TRUE)) #>       row   col     dist    lower    upper #> 136 ethmp ethma 1.377873 1.279108 1.479039 #> 697  rpto  lpto 1.131002 1.087753 1.164933 #> 179 laalf ethmp 1.095672 1.070444 1.124045 #> 200 raalf ethmp 1.094267 1.067043 1.125650 #> 881  rpmx raalf 1.080811 1.061278 1.103610 #> 607  rpns  lpns 1.078698 1.058532 1.122745 head(get_fdm(fdm, sort=TRUE, decreasing=FALSE)) #>        row   col      dist     lower     upper #> 527   lsqu  lpfl 0.8622059 0.8089977 0.9459507 #> 1022  rsqu  rpfl 0.8781312 0.8243285 0.9393457 #> 93   ethmp  cpsh 0.9034404 0.8810750 0.9250952 #> 212   rpsh ethmp 0.9177018 0.8965352 0.9395801 #> 190   lpsh ethmp 0.9181652 0.8947758 0.9348729 #> 4    ethmp amsph 0.9401242 0.9278436 0.9510568 head(confint(fdm)) #>                  2.5%     97.5% #> bas-amsph   1.0291234 1.0572437 #> cpsh-amsph  0.9616780 0.9988809 #> ethma-amsph 0.9914403 1.0156289 #> ethmp-amsph 0.9278436 0.9510568 #> laalf-amsph 0.9788081 0.9990751 #> lasph-amsph 0.9891307 1.0317053 plot_ci(fdm, xshow=FALSE) library(ggplot2) df <- get_fdm(fdm, sort=TRUE) df$x <- 1:nrow(df) # make x-axis continuous df$name <- paste(df$row, df$col) # add names p <- ggplot(data=df, aes(x=x, y=dist,      ymin=lower, ymax=upper, label=name)) +   geom_ribbon(col=\"#0000ff40\", fill=\"#0000ff40\") +   geom_line() +   geom_hline(yintercept=1, col=2) +   labs(y=\"FDM Ratio\", x=\"Landmark Pairs\") +   theme_linedraw() +   theme(axis.text.x=element_blank()) p library(plotly) ggplotly(p)"},{"path":"/articles/edma03-form-difference.html","id":"influential-landmarks","dir":"Articles","previous_headings":"","what":"Influential landmarks","title":"EDMA form difference matrix","text":"can consider landmark influential respect form difference removing landmark, global T value moves close 1. case indicate landmark question driving form differences (.e. pairwise distances landmark landmarks contribute maximum value T statistic). , however, remove non-influential landmark, expect T value change lot. Therefore, ‘drop’ T value removing landmark can used rank landmarks based influence. Influential landmarks identified leaving one landmark time, calculating T-statistic based remaining distances. can use bootstrap distribution see T value ‘drop’ makes global test non-significant. means removing landmark, form difference distinguished null expectation. influential landmark one largest drop T value compared original T statistic. Tdrop newly calculated T value leaving landmark question: Note: used order function create index order rows infl data frame. get_influence also takes level argument specifying desired confidence interval (default 95%). plot function shows landmarks ordered Tdrop influential landmarks left-hand side plot. horizontal line top indicates original T value (landmarks considered), increasing line shows Tdrop, shaded area null distribution T statistic:  ggplot2 version:  interactive version:","code":"infl <- get_influence(fdm) head(infl[order(infl$Tdrop),], 10) #>    landmark    Tdrop    lower    upper #> 4     ethma 1.311754 1.074204 1.253519 #> 5     ethmp 1.311754 1.074204 1.253519 #> 14     lpfl 1.569097 1.074204 1.350022 #> 21     lsqu 1.569097 1.074204 1.350022 #> 1     amsph 1.598078 1.074204 1.360890 #> 2       bas 1.598078 1.074204 1.360890 #> 3      cpsh 1.598078 1.074204 1.360890 #> 6     laalf 1.598078 1.074204 1.360890 #> 7     lasph 1.598078 1.074204 1.360890 #> 8     lflac 1.598078 1.074204 1.360890 plot(infl) df <- infl[order(infl$Tdrop),] df$landmark <- factor(as.character(df$landmark), as.character(df$landmark)) p <- ggplot(data=df, aes(x=landmark, y=Tdrop, ymin=lower, ymax=upper, group=1)) +   geom_ribbon(col=\"#0000ff40\", fill=\"#0000ff40\") +   geom_hline(yintercept=global_test(fdm)$statistic, col=2) +   geom_line() +   labs(y=\"T-value\", x=\"Landmarks\") +   theme(axis.text.x=element_text(angle = 45,         vjust = 1, hjust=1)) p ggplotly(p)"},{"path":"/articles/edma03-form-difference.html","id":"ordination-and-clustering-for-specimens","dir":"Articles","previous_headings":"","what":"Ordination and clustering for specimens","title":"EDMA form difference matrix","text":"ordination cluster dendrogram shows two sets specimens 2 objects diagram. 2 sets combined combine_data function: visualization otherwise use principles described EDMA data objects. difference specimens labels colored (using default qualitative palette) according groups (numerator vs. denominator). numerator denominator objects different (global T value high, \\(p\\) value low, influential landmarks), expect two groups separate ordination space along dendrogram:  dendrogram leaves (specimen labels) also colored groups:  colors can changed via color options:","code":"x1 #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 3 dimensions, 28 specimens x2 #> EDMA data: Crouzon P0 UNAFF #> 47 landmarks, 3 dimensions, 31 specimens (x12 <- combine_data(x1, x2)) #> EDMA data: data with 2 groups #> 47 landmarks, 3 dimensions, 59 specimens table(x12$groups) #>  #>  1  2  #> 28 31 plot_ord(fdm) plot_clust(fdm) op <- options(\"edma_options\" = list(     diverging = \"Blue-Red\",     qualitative = \"Warm\")) plot_ord(fdm) options(op)"},{"path":"/articles/edma03-form-difference.html","id":"visualizing-landmarks","dir":"Articles","previous_headings":"","what":"Visualizing landmarks","title":"EDMA form difference matrix","text":"2D 3D plots produce plot mean form reference object (‘prototype’). color intensity landmarks (dots) associated Tdrop influence value (larger difference, intensive color; red default). Lines landmarks represent distances. use diverging palettes: <1 differences colored blue (1st half palette), >1 differences colored red (2st half palette).  2D 3D plots display pairwise distances. displaying edges desired, use =TRUE argument.","code":"plot_2d(fdm, cex=2) library(rgl) xyz <- plot_3d(fdm) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Introduction","title":"Parametric estimation","text":"tutorial describes estimate SigmaK assess estimable. Parametric estimation SigmaK involves following steps: non-parametric estimation mean form SigmaKstar using edma_fit function, constructing pattern matrix based biology landmarks respecting statistical constraints, use SigmaK_fit estimate SigmaK using non-parametric fit pattern matrix.","code":"library(EDMAinR) #> EDMAinR 0.1-6     2020-10-01"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Simulated landmark data","title":"Parametric estimation","text":"demonstrate workflow, let us simulate data. Simulation useful checking limits estimating procedure. know ‘true’ input , controlling simulation. can compare outputs (estimates), known inputs, evaluate utility limitations methods. Let us begin following set 6 landmarks 2-dimensions:  simplest SigmaK variance-covariance matrix \\(\\sigma^2 \\), constant variance (\\(\\sigma^2\\)) diagonal \\(6\\times6\\) square matrix 0’s -diagonal cells: can use edma_simulate_data function simulate n specimen given form matrix M covariance matrix SigmaK:  can see figure constant variance translates roughly circle shaped convex hulls around landmarks (hull bounds landmarks form n specimens), size patches similar (equal variances).","code":"(M <- array(   c(82, 21, 22, -50, -37, -37,    0,  17, -17, 0,  41,  -41),    dim=c(6, 2),   dimnames=list(paste0(\"L\", 1:6), c(\"X\", \"Y\")))) #>      X   Y #> L1  82   0 #> L2  21  17 #> L3  22 -17 #> L4 -50   0 #> L5 -37  41 #> L6 -37 -41 plot(M, pch=3, asp=1, axes=FALSE, ann=FALSE, type=\"n\") text(M, labels=rownames(M), col=4) sigma <- 2 SigmaK <- diag(sigma^2, 6, 6) dimnames(SigmaK) <- list(rownames(M), rownames(M)) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1  4  .  .  .  .  . #> L2  .  4  .  .  .  . #> L3  .  .  4  .  .  . #> L4  .  .  .  4  .  . #> L5  .  .  .  .  4  . #> L6  .  .  .  .  .  4 n <- 1000 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4)"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Nonparametric estimation","title":"Parametric estimation","text":"use non-parametric EDMA algorithm estimate form matrix SigmaKstar matrix: used simulations, can compare known M matrix estimated mean form: ‘true’ SigmaKstar matrix stored simulation object:","code":"fit <- edma_fit(sim) M                       # true #>      X   Y #> L1  82   0 #> L2  21  17 #> L3  22 -17 #> L4 -50   0 #> L5 -37  41 #> L6 -37 -41 round(Meanform(fit), 2) # estimate #>         X      Y #> L1 -81.87   0.12 #> L2 -20.80  17.10 #> L3 -21.89 -16.96 #> L4  50.30  -0.17 #> L5  37.20  40.95 #> L6  37.06 -41.03 round(attr(sim, \"simulation_settings\")$SigmaKstar, 2) #>       L1    L2    L3    L4    L5    L6 #> L1  3.33 -0.67 -0.67 -0.67 -0.67 -0.67 #> L2 -0.67  3.33 -0.67 -0.67 -0.67 -0.67 #> L3 -0.67 -0.67  3.33 -0.67 -0.67 -0.67 #> L4 -0.67 -0.67 -0.67  3.33 -0.67 -0.67 #> L5 -0.67 -0.67 -0.67 -0.67  3.33 -0.67 #> L6 -0.67 -0.67 -0.67 -0.67 -0.67  3.33 round(SigmaKstar(fit), 2) #>       L1    L2    L3    L4    L5    L6 #> L1  3.43 -0.68 -0.58 -0.82 -0.90 -0.46 #> L2 -0.68  3.43 -0.70 -0.71 -0.64 -0.71 #> L3 -0.58 -0.70  3.51 -0.84 -0.72 -0.66 #> L4 -0.82 -0.71 -0.84  3.55 -0.42 -0.77 #> L5 -0.90 -0.64 -0.72 -0.42  3.22 -0.54 #> L6 -0.46 -0.71 -0.66 -0.77 -0.54  3.14"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Pattern matrix","title":"Parametric estimation","text":"parametric estimation requires pattern matrix describes unknowns SigmaK matrix. SigmaK matrix variance covariance matrix describing variances (diagonal) associated landmark, covariances (-diagonal) among landmarks. pattern matrix can constructed R, number landmarks high variances expected differ among landmarks, might easier construct pattern matrix spreadsheet editor (Excel). file constructed (package contains example files, see ?read_pattern): 1st row describes landmarks starting 2nd column, 1st column describes landmarks order column headers, leave cell top left corner empty, use unique names numbers rest table denote unique variables Sigma matrix, structural zeros (cells covariance known assumed 0) blank, blank cells diagonal matrix, values diagonal must symmetric (value row 2/column 3 must row 3/column 2), either unique names numbers, blank. pattern matrix equal variance case looks like :","code":"p <- matrix(   c(\"1\", NA, NA, NA,  NA,  NA,     NA, \"1\", NA, NA,  NA,  NA,     NA, NA, \"1\", NA,  NA,  NA,     NA,  NA,  NA, \"1\", NA, NA,     NA,  NA,  NA, NA, \"1\", NA,     NA,  NA,  NA, NA, NA, \"1\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) print_tb(p) #>    L1 L2 L3 L4 L5 L6 #> L1 1  .  .  .  .  .  #> L2 .  1  .  .  .  .  #> L3 .  .  1  .  .  .  #> L4 .  .  .  1  .  .  #> L5 .  .  .  .  1  .  #> L6 .  .  .  .  .  1"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Parametric estimation","title":"Parametric estimation","text":"parametric estimation requires fitted object previous step nonparametric estimation (gave us estimate mean form SigmaKstar), pattern matrix, program knows parameters estimate placed SigmaK matrix: Now let us compare ‘true’ SigmaK matrix estimated ones. ‘full’ estimate SigmaK can accessed SigmaKfull function follows Hu (2007). can see SigmaKfull matrix values slightly different, algorithm treats every non-NA entry pattern matrix (non-0 cell SigmaK matrix estimated) unknown variable. SigmaK default returns estimates constrained pattern matrix. call default method 2-step algorithm numerical optimization follows estimation SigmaKfull. use pattern matrix constrain parameters denoted labels value. Let’s see value get constant variance parameter: method call 1-step algorithm numerical optimization performed without information SigmaKfull. uses SigmaKstar matrix. can use algorithm : estimates look close true estimate.","code":"(o <- SigmaK_fit(fit, p)) #> EDMA parametric fit (1-step): Simulated landmark data #> Call: SigmaK_fit(object = fit, pattern = p) #> 6 landmarks, 2 dimensions, 1000 specimens, no bootstrap print_tb(SigmaK)                  # true #>    L1 L2 L3 L4 L5 L6 #> L1  4  .  .  .  .  . #> L2  .  4  .  .  .  . #> L3  .  .  4  .  .  . #> L4  .  .  .  4  .  . #> L5  .  .  .  .  4  . #> L6  .  .  .  .  .  4 print_tb(round(SigmaKfull(o), 2)) # full estimate #>      L1   L2   L3   L4   L5   L6 #> L1 4.14    .    .    .    .    . #> L2    . 4.08    .    .    .    . #> L3    .    . 3.97    .    .    . #> L4    .    .    . 4.48    .    . #> L5    .    .    .    . 4.32    . #> L6    .    .    .    .    . 3.35 print_tb(SigmaK)              # true #>    L1 L2 L3 L4 L5 L6 #> L1  4  .  .  .  .  . #> L2  .  4  .  .  .  . #> L3  .  .  4  .  .  . #> L4  .  .  .  4  .  . #> L5  .  .  .  .  4  . #> L6  .  .  .  .  .  4 print_tb(round(SigmaK(o), 2)) # constrained estimate #>      A    B    C    D    E    F #> A 4.06    .    .    .    .    . #> B    . 4.06    .    .    .    . #> C    .    . 4.06    .    .    . #> D    .    .    . 4.06    .    . #> E    .    .    .    . 4.06    . #> F    .    .    .    .    . 4.06 cbind(true=sigma^2, estimate=o$results$par) #>   true estimate #> 1    4 4.056236 (o1 <- SigmaK_fit(fit, p, twostep=FALSE)) #> EDMA parametric fit (1-step): Simulated landmark data #> Call: SigmaK_fit(object = fit, pattern = p, twostep = FALSE) #> 6 landmarks, 2 dimensions, 1000 specimens, no bootstrap cbind(true=sigma^2, onestep=o1$results$par, twostep=o$results$par) #>   true  onestep  twostep #> 1    4 4.056236 4.056236"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Unequal variance case","title":"Parametric estimation","text":"unequal variance case can different variances different landmarks. corresponding pattern matrix:  SigmaK matrix looks like : unequal variances translate following simulated data:  can see different sizes convex hulls corresponding variances landmark. estimation, use edma_fit SigmaK_fit : Let’s 6 different values diagonal:  SigmaK matrix looks like : translates following simulated data:  can now see constrained full solutions identical, parameters repeated pattern matrix: can see 1-step 2-step algorithms give estimates close true values correlations (-diagonal elements) SigmaK 0 (coded NA pattern matrix).","code":"p <- matrix(   c(\"1\", NA,  NA, NA,  NA,  NA,     NA, \"1\", NA, NA,  NA,  NA,     NA,  NA, \"1\", NA,  NA,  NA,     NA,  NA,  NA, \"2\", NA,  NA,     NA,  NA,  NA, NA, \"2\", NA,     NA,  NA,  NA, NA,  NA, \"2\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) plot_tb(p) parm <- c(\"1\"=12, \"2\"=2) SigmaK <- make_Sigma(parm, p) dimnames(SigmaK) <- dimnames(p) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1 12  .  .  .  .  . #> L2  . 12  .  .  .  . #> L3  .  . 12  .  .  . #> L4  .  .  .  2  .  . #> L5  .  .  .  .  2  . #> L6  .  .  .  .  .  2 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4) fit <- edma_fit(sim) o1 <- SigmaK_fit(fit, p, twostep=FALSE) o2 <- SigmaK_fit(fit, p, twostep=TRUE) print_tb(SigmaK)                   # true #>    L1 L2 L3 L4 L5 L6 #> L1 12  .  .  .  .  . #> L2  . 12  .  .  .  . #> L3  .  . 12  .  .  . #> L4  .  .  .  2  .  . #> L5  .  .  .  .  2  . #> L6  .  .  .  .  .  2 print_tb(round(SigmaKfull(o2), 2)) # full estimate #>       L1    L2    L3    L4    L5    L6 #> L1 11.89     .     .     .     .     . #> L2     . 10.28     .     .     .     . #> L3     .     . 12.99     .     .     . #> L4     .     .     .  2.30     .     . #> L5     .     .     .     .  1.92     . #> L6     .     .     .     .     .  2.59 cbind(true=parm,    onestep=o1$results$par[names(parm)],    twostep=o2$results$par[names(parm)]) #>   true   onestep   twostep #> 1   12 11.825347 11.721269 #> 2    2  2.165456  2.269536 p <- matrix(   c(\"1\", NA,  NA, NA,  NA,  NA,     NA, \"2\", NA, NA,  NA,  NA,     NA,  NA, \"3\", NA,  NA,  NA,     NA,  NA,  NA, \"4\", NA,  NA,     NA,  NA,  NA, NA, \"5\", NA,     NA,  NA,  NA, NA,  NA, \"6\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) plot_tb(p) parm <- c(\"1\"=12, \"2\"=8, \"3\"=11, \"4\"=3, \"5\"=10, \"6\"=2) SigmaK <- make_Sigma(parm, p) dimnames(SigmaK) <- dimnames(p) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1 12  .  .  .  .  . #> L2  .  8  .  .  .  . #> L3  .  . 11  .  .  . #> L4  .  .  .  3  .  . #> L5  .  .  .  . 10  . #> L6  .  .  .  .  .  2 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4) fit <- edma_fit(sim) o1 <- SigmaK_fit(fit, p, twostep=FALSE) o2 <- SigmaK_fit(fit, p, twostep=TRUE) print_tb(SigmaK)                   # true #>    L1 L2 L3 L4 L5 L6 #> L1 12  .  .  .  .  . #> L2  .  8  .  .  .  . #> L3  .  . 11  .  .  . #> L4  .  .  .  3  .  . #> L5  .  .  .  . 10  . #> L6  .  .  .  .  .  2 print_tb(round(SigmaKfull(o2), 2)) # full estimate #>       L1    L2    L3    L4    L5    L6 #> L1 11.50     .     .     .     .     . #> L2     .  8.43     .     .     .     . #> L3     .     . 12.25     .     .     . #> L4     .     .     .  2.16     .     . #> L5     .     .     .     .  8.69     . #> L6     .     .     .     .     .  2.52 cbind(true=parm,    onestep=o1$results$par[names(parm)],    twostep=o2$results$par[names(parm)]) #>   true   onestep   twostep #> 1   12 11.498857 11.498709 #> 2    8  8.245809  8.425900 #> 3   11 11.042865 12.248140 #> 4    3  2.760571  2.164662 #> 5   10  9.881921  8.687253 #> 6    2  2.112453  2.518331"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Correlations","title":"Parametric estimation","text":"can add correlations frontal (L1) lateral (L2, L3) landmarks, similarly 3 landmarks:  SigmaK matrix looks like : unequal variances translate following simulated data:  setup seems estimable:","code":"p <- matrix(   c(\"1\", \"2\", \"2\", NA,  NA,  NA,     \"2\", \"1\", NA,  NA,  NA,  NA,     \"2\", NA,  \"1\", NA,  NA,  NA,     NA,  NA,  NA,  \"3\", \"4\", \"4\",     NA,  NA,  NA,  \"4\", \"3\", NA,     NA,  NA,  NA,  \"4\", NA,  \"3\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) plot_tb(p) parm <- c(\"1\"=12, \"2\"=1, \"3\"=8, \"4\"=2) SigmaK <- EDMAinR:::.vec2mat(parm, EDMAinR:::.mat2fac(p)) dimnames(SigmaK) <- dimnames(p) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1 12  1  1  .  .  . #> L2  1 12  .  .  .  . #> L3  1  . 12  .  .  . #> L4  .  .  .  8  2  2 #> L5  .  .  .  2  8  . #> L6  .  .  .  2  .  8 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4) fit <- edma_fit(sim) o1 <- SigmaK_fit(fit, p, twostep=FALSE) o2 <- SigmaK_fit(fit, p, twostep=TRUE) print_tb(SigmaK)                   # true #>    L1 L2 L3 L4 L5 L6 #> L1 12  1  1  .  .  . #> L2  1 12  .  .  .  . #> L3  1  . 12  .  .  . #> L4  .  .  .  8  2  2 #> L5  .  .  .  2  8  . #> L6  .  .  .  2  .  8 print_tb(round(SigmaKfull(o2), 2)) # full estimate #>       L1    L2    L3    L4    L5    L6 #> L1 11.57  0.98  1.58     .     .     . #> L2  0.98 12.15     .     .     .     . #> L3  1.58     . 12.31     .     .     . #> L4     .     .     .  7.46  2.00  1.36 #> L5     .     .     .  2.00  8.32     . #> L6     .     .     .  1.36     .  8.63 cbind(true=parm,    onestep=o1$results$par[names(parm)],    twostep=o2$results$par[names(parm)]) #>   true   onestep   twostep #> 1   12 11.988982 12.012470 #> 2    1  1.291689  1.277877 #> 3    8  8.200966  8.133914 #> 4    2  1.829278  1.679760"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Sensitivity analysis","title":"Parametric estimation","text":"parametric estimate based optimization algorithm. algorithm requires starting values unknown parameters. robustness estimates can tested using different starting values optimization. idea can call estimates stable optimization finds values irrespective starting values. can assess results regard using sensitivity function. function repeats estimation m times using starting value original starting value times random uniform number. idea can applied 1-step 1-step estimator: par_1, par_2, etc. columns shows parameter estimates unknown variables, value column shows value loss function evaluated parameter values. row represent separate run, 1st row original estimate, rest repeated runs different starting values. see case 2-step estimator less sensitive starting values, methods provide similar estimates loss function values.","code":"sensitivity(o1) #>          par_1    par_2    par_3    par_4    value #>  [1,] 11.98898 1.291689 8.200966 1.829278 1.770413 #>  [2,] 11.98897 1.294422 8.198867 1.833990 1.770523 #>  [3,] 11.98557 1.282750 8.206205 1.832114 1.770555 #>  [4,] 12.00125 1.300504 8.195235 1.834312 1.770929 #>  [5,] 11.98718 1.290446 8.202447 1.830951 1.770420 #>  [6,] 11.98915 1.286699 8.205750 1.831073 1.770494 #>  [7,] 11.99169 1.286468 8.216681 1.836992 1.770929 #>  [8,] 11.99146 1.287296 8.198470 1.827432 1.770516 #>  [9,] 11.98764 1.295328 8.189940 1.815521 1.770840 #> [10,] 11.98432 1.287713 8.204633 1.827749 1.770503 #> [11,] 12.01228 1.282848 8.219605 1.831498 1.773071 sensitivity(o2) #>          par_1    par_2    par_3    par_4        value #>  [1,] 12.01247 1.277877 8.133914 1.679760 0.000000e+00 #>  [2,] 12.01158 1.278736 8.135852 1.678110 8.012206e-06 #>  [3,] 12.01664 1.270053 8.130103 1.681810 9.733175e-05 #>  [4,] 12.01298 1.278160 8.134899 1.680438 1.774786e-06 #>  [5,] 12.01304 1.275850 8.131526 1.678458 1.183108e-05 #>  [6,] 12.01185 1.277407 8.133567 1.680789 1.785666e-06 #>  [7,] 12.02086 1.273592 8.134955 1.679580 8.980361e-05 #>  [8,] 12.02192 1.285185 8.121670 1.678262 2.948211e-04 #>  [9,] 12.00946 1.277510 8.137112 1.676533 2.980716e-05 #> [10,] 12.01085 1.278701 8.134720 1.679006 4.504664e-06 #> [11,] 12.01364 1.277477 8.132173 1.674293 3.443842e-05"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Non-estimable case: equi-correlation","title":"Parametric estimation","text":"following parametrization common parametrization. see, contrary intuition models unknowns (single variance single covariance term) identifiable, model actually non-identifiable. Let us walk steps estimating parameters look signs non-identifiability:  diagonal elements \\(\\sigma^2\\) (equal variance), diagonal elements \\(\\sigma^2\\rho\\) \\(\\rho\\) correlation: correlation lead ellipsoid shapes simulated landmarks:  Oops, get error cases. Based Hu (2007), need certain number 0s SigmaK matrix able identify parameters. number non-zero values larger \\(K (K-1)/2\\) (counting elements diagonal lower triangle ). error informs us . check argument can used disable check see get disregard mathematical results: Interesting. 1-step estimator works depend SigmaKfull. 2-step estimator, however, fails called \\(\\) matrix need estimate SigmaKfull non-invertible. Let’s investigate sensitivity analysis results 1-step estimator: clear sign non-identifiability loss function values identical across runs, estimates vary widely. Just reminder, true values 10 variance 2 covariance.","code":"p <- matrix(   c(\"1\", \"2\", \"2\", \"2\", \"2\", \"2\",     \"2\", \"1\", \"2\", \"2\", \"2\", \"2\",     \"2\", \"2\", \"1\", \"2\", \"2\", \"2\",     \"2\", \"2\", \"2\", \"1\", \"2\", \"2\",     \"2\", \"2\", \"2\", \"2\", \"1\", \"2\",     \"2\", \"2\", \"2\", \"2\", \"2\", \"1\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) plot_tb(p) parm <- c(\"1\"=10, \"2\"=2) SigmaK <- EDMAinR:::.vec2mat(parm, EDMAinR:::.mat2fac(p)) dimnames(SigmaK) <- dimnames(p) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1 10  2  2  2  2  2 #> L2  2 10  2  2  2  2 #> L3  2  2 10  2  2  2 #> L4  2  2  2 10  2  2 #> L5  2  2  2  2 10  2 #> L6  2  2  2  2  2 10 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4) fit <- edma_fit(sim) try(o1 <- SigmaK_fit(fit, p, twostep=FALSE)) #> Error in .SigmaK_fit(object$SigmaKstar, pattern, twostep = twostep, check = check,  :  #>   Too many unknowns (21 > 15) in pattern matrix. try(o2 <- SigmaK_fit(fit, p, twostep=TRUE)) #> Error in .SigmaK_fit(object$SigmaKstar, pattern, twostep = twostep, check = check,  :  #>   Too many unknowns (21 > 15) in pattern matrix. try(o1 <- SigmaK_fit(fit, p, twostep=FALSE, check=FALSE)) try(o2 <- SigmaK_fit(fit, p, twostep=TRUE, check=FALSE)) #> Error in .SigmaK_fit(object$SigmaKstar, pattern, twostep = twostep, check = check,  :  #>   Error in .SigmaK_fit_full(SigmaKstar, pattern) :  #>   Pattern matrix leads to non-invertible A matrix. sensitivity(o1) #>           par_1      par_2    value #>  [1,]  4.748531 -3.4691179 1.648628 #>  [2,]  6.890880 -1.3262843 1.648628 #>  [3,]  6.151392 -2.0663959 1.648629 #>  [4,]  6.452819 -1.7642788 1.648628 #>  [5,]  8.568215  0.3510408 1.648628 #>  [6,]  8.751653  0.5345982 1.648628 #>  [7,] 10.031098  1.8137888 1.648628 #>  [8,] 10.092239  1.8747895 1.648628 #>  [9,]  9.797219  1.5798604 1.648628 #> [10,] 13.610085  5.3924150 1.648628 #> [11,]  7.928411 -0.2889969 1.648628"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Non-estimable case: blocks","title":"Parametric estimation","text":"can add correlations frontal (L1) lateral (L2, L3) landmarks, similarly 3 landmarks:  number non-zero entries (diagonal lower triangle) case 12 less \\(K(K-1)/2=15\\). According simple rule thumb , work. bloc design translates following simulated data:  Although 12 < 15, setup still leads non-ivertible \\(\\) matrix 2-step algorithm, can see clear signs non-estimability 1-step algorithm based sensitivity analysis:","code":"p <- matrix(   c(\"1\", \"2\", \"2\", NA,  NA,  NA,     \"2\", \"1\", \"2\",  NA,  NA,  NA,     \"2\", \"2\", \"1\", NA,  NA,  NA,     NA,  NA,  NA,  \"3\", \"4\", \"4\",     NA,  NA,  NA,  \"4\", \"3\", \"4\",     NA,  NA,  NA,  \"4\", \"4\",\"3\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) plot_tb(p) parm <- c(\"1\"=12, \"2\"=1, \"3\"=8, \"4\"=2) SigmaK <- EDMAinR:::.vec2mat(parm, EDMAinR:::.mat2fac(p)) dimnames(SigmaK) <- dimnames(p) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1 12  1  1  .  .  . #> L2  1 12  1  .  .  . #> L3  1  1 12  .  .  . #> L4  .  .  .  8  2  2 #> L5  .  .  .  2  8  2 #> L6  .  .  .  2  2  8 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4) fit <- edma_fit(sim) try(o1 <- SigmaK_fit(fit, p, twostep=FALSE, check=FALSE)) try(o2 <- SigmaK_fit(fit, p, twostep=TRUE, check=FALSE)) #> Error in .SigmaK_fit(object$SigmaKstar, pattern, twostep = twostep, check = check,  :  #>   Error in .SigmaK_fit_full(SigmaKstar, pattern) :  #>   Pattern matrix leads to non-invertible A matrix. sensitivity(o1) #>           par_1       par_2     par_3      par_4    value #>  [1,] 15.164106  4.40603918  4.368686 -1.3228632 2.134815 #>  [2,]  7.742781 -3.01601959 11.791203  6.0997825 2.134820 #>  [3,] 13.030156  2.27228960  6.501521  0.8108885 2.134815 #>  [4,] 12.703420  1.94567126  6.828631  1.1369303 2.134815 #>  [5,] 12.277616  1.51973461  7.255024  1.5639104 2.134815 #>  [6,]  8.085943 -2.67088711 11.446278  5.7547026 2.134815 #>  [7,] 13.967915  3.21107553  5.563649 -0.1275584 2.134815 #>  [8,]  4.842881 -5.91486050 14.689484  8.9972697 2.134816 #>  [9,] 10.753748 -0.00333326  8.777853  3.0868331 2.134814 #> [10,]  9.177126 -1.58054022 10.355324  4.6639958 2.134814 #> [11,]  3.424321 -7.33235585 16.106952 10.4154903 2.134815"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"An estimable block pattern","title":"Parametric estimation","text":"Let’s try slight variation block design:  12 non-zero entries, 0 1st row 2nd colum 3rd row 1st column (pair upper triangle).  Everything looks fine now: default checks SigmaK_fit can catch non-identifiable situation. Use check=FALSE twostep=FALSE options care.","code":"p <- matrix(   c(\"1\", \"2\", \"2\", \"2\",  NA,  NA,     \"2\", \"1\", NA,  NA,   NA,  NA,     \"2\", NA,  \"1\", NA,   NA,  NA,     \"2\", NA,  NA,  \"3\",  \"4\", \"4\",     NA,  NA,  NA,  \"4\",  \"3\", \"4\",     NA,  NA,  NA,  \"4\",  \"4\",\"3\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p) <- list(rownames(M), rownames(M)) plot_tb(p) parm <- c(\"1\"=12, \"2\"=1, \"3\"=8, \"4\"=2) SigmaK <- EDMAinR:::.vec2mat(parm, EDMAinR:::.mat2fac(p)) dimnames(SigmaK) <- dimnames(p) print_tb(SigmaK) #>    L1 L2 L3 L4 L5 L6 #> L1 12  1  1  1  .  . #> L2  1 12  .  .  .  . #> L3  1  . 12  .  .  . #> L4  1  .  .  8  2  2 #> L5  .  .  .  2  8  2 #> L6  .  .  .  2  2  8 sim <- edma_simulate_data(n=n, M, SigmaK)  tmp <- plot_2d(sim, xlim=c(-80, 100), ylim=c(-60, 60), asp=1) xy <- attr(tmp, \"coordinates\") text(xy[,1]+15, xy[,2], labels=rownames(xy), cex=0.6, col=4) fit <- edma_fit(sim) o1 <- SigmaK_fit(fit, p, twostep=FALSE) o2 <- SigmaK_fit(fit, p, twostep=TRUE)  print_tb(SigmaK)                   # true #>    L1 L2 L3 L4 L5 L6 #> L1 12  1  1  1  .  . #> L2  1 12  .  .  .  . #> L3  1  . 12  .  .  . #> L4  1  .  .  8  2  2 #> L5  .  .  .  2  8  2 #> L6  .  .  .  2  2  8 print_tb(round(SigmaKfull(o2), 2)) # full estimate #>       L1    L2    L3    L4    L5    L6 #> L1 12.88  2.80  1.90  0.27     .     . #> L2  2.80 13.46     .     .     .     . #> L3  1.90     . 13.15     .     .     . #> L4  0.27     .     .  6.00  0.54  0.80 #> L5     .     .     .  0.54  6.26  1.14 #> L6     .     .     .  0.80  1.14  8.03 cbind(true=parm,    onestep=o1$results$par[names(parm)],    twostep=o2$results$par[names(parm)]) #>   true   onestep   twostep #> 1   12 12.573567 13.162196 #> 2    1  1.468189  1.657838 #> 3    8  7.615555  6.761063 #> 4    2  1.682164  0.827751  sensitivity(o1) #>          par_1    par_2    par_3    par_4    value #>  [1,] 12.57357 1.468189 7.615555 1.682164 5.975322 #>  [2,] 12.58071 1.472606 7.605482 1.674960 5.975466 #>  [3,] 12.57003 1.472980 7.612560 1.678754 5.975490 #>  [4,] 12.56653 1.465929 7.621837 1.691717 5.975483 #>  [5,] 12.57396 1.470649 7.609983 1.676606 5.975394 #>  [6,] 12.57319 1.468542 7.612556 1.682648 5.975348 #>  [7,] 12.56442 1.466028 7.619740 1.687996 5.975462 #>  [8,] 12.58323 1.468371 7.606760 1.675192 5.975550 #>  [9,] 12.57912 1.469446 7.614010 1.679855 5.975370 #> [10,] 12.58000 1.468876 7.614391 1.681572 5.975398 #> [11,] 12.57062 1.466483 7.613593 1.683689 5.975360 sensitivity(o2) #>          par_1    par_2    par_3     par_4        value #>  [1,] 13.16220 1.657838 6.761063 0.8277510 0.000000e+00 #>  [2,] 13.16222 1.657624 6.764423 0.8243226 2.309325e-05 #>  [3,] 13.16115 1.655461 6.760147 0.8263303 9.602650e-06 #>  [4,] 13.16053 1.657458 6.761152 0.8267646 3.897586e-06 #>  [5,] 13.16457 1.659400 6.760337 0.8248463 1.702563e-05 #>  [6,] 13.15444 1.648954 6.755374 0.8249546 1.792628e-04 #>  [7,] 13.15916 1.656532 6.761350 0.8282018 1.120905e-05 #>  [8,] 13.14011 1.673423 6.761018 0.8316202 7.454372e-04 #>  [9,] 13.16342 1.657751 6.761367 0.8270895 2.034351e-06 #> [10,] 13.15530 1.655695 6.758825 0.8335177 9.037772e-05 #> [11,] 13.17617 1.672984 6.771555 0.8306727 5.433578e-04"},{"path":"/articles/edma03-parametric.html","id":null,"dir":"Articles","previous_headings":"","what":"Selecting the best parametric model","title":"Parametric estimation","text":"Assumptions biological mechanisms driving 0 pattern covariance matrix can help researchers formulate hypotheses. hypotheses translate patterns estimable, can use loss function value 1-step estimator tell model fits data better: use p1 pattern matrix simulate data, use 5 identifiable patterns try estimate parametric SigmaK matrix. fit 5 models, compare loss function values. model smallest loss function value best:","code":"p1 <- matrix(   c(\"1\", NA, NA, NA,  NA,  NA,     NA, \"1\", NA, NA,  NA,  NA,     NA, NA, \"1\", NA,  NA,  NA,     NA,  NA,  NA, \"1\", NA, NA,     NA,  NA,  NA, NA, \"1\", NA,     NA,  NA,  NA, NA, NA, \"1\"),   nrow=6, ncol=6, byrow=TRUE) p2 <- matrix(   c(\"1\", NA,  NA, NA,  NA,  NA,     NA, \"1\", NA, NA,  NA,  NA,     NA,  NA, \"1\", NA,  NA,  NA,     NA,  NA,  NA, \"2\", NA,  NA,     NA,  NA,  NA, NA, \"2\", NA,     NA,  NA,  NA, NA,  NA, \"2\"),   nrow=6, ncol=6, byrow=TRUE) p3 <- matrix(   c(\"1\", NA,  NA, NA,  NA,  NA,     NA, \"2\", NA, NA,  NA,  NA,     NA,  NA, \"3\", NA,  NA,  NA,     NA,  NA,  NA, \"4\", NA,  NA,     NA,  NA,  NA, NA, \"5\", NA,     NA,  NA,  NA, NA,  NA, \"6\"),   nrow=6, ncol=6, byrow=TRUE) p4 <- matrix(   c(\"1\", \"2\", \"2\", NA,  NA,  NA,     \"2\", \"1\", NA,  NA,  NA,  NA,     \"2\", NA,  \"1\", NA,  NA,  NA,     NA,  NA,  NA,  \"3\", \"4\", \"4\",     NA,  NA,  NA,  \"4\", \"3\", NA,     NA,  NA,  NA,  \"4\", NA,  \"3\"),   nrow=6, ncol=6, byrow=TRUE) p5 <- matrix(   c(\"1\", \"2\", \"2\", \"2\",  NA,  NA,     \"2\", \"1\", NA,  NA,   NA,  NA,     \"2\", NA,  \"1\", NA,   NA,  NA,     \"2\", NA,  NA,  \"3\",  \"4\", \"4\",     NA,  NA,  NA,  \"4\",  \"3\", \"4\",     NA,  NA,  NA,  \"4\",  \"4\",\"3\"),   nrow=6, ncol=6, byrow=TRUE) dimnames(p1) <- list(rownames(M), rownames(M)) dimnames(p2) <- list(rownames(M), rownames(M)) dimnames(p3) <- list(rownames(M), rownames(M)) dimnames(p4) <- list(rownames(M), rownames(M)) dimnames(p5) <- list(rownames(M), rownames(M))  parm <- c(\"1\"=12, \"2\"=1, \"3\"=8, \"4\"=2) SigmaK <- EDMAinR:::.vec2mat(parm, EDMAinR:::.mat2fac(p4)) dimnames(SigmaK) <- dimnames(p4) sim <- edma_simulate_data(n=n, M, SigmaK) fit <- edma_fit(sim) o1 <- SigmaK_fit(fit, p1, twostep=FALSE) o2 <- SigmaK_fit(fit, p2, twostep=FALSE) o3 <- SigmaK_fit(fit, p3, twostep=FALSE) o4 <- SigmaK_fit(fit, p4, twostep=FALSE) o5 <- SigmaK_fit(fit, p5, twostep=FALSE)  value <- sapply(list(o1, o2, o3, o4, o5), function(o) {   o$results$value })  data.frame(   model=1:5,   value=value,   delta=value - min(value)) #>   model     value    delta #> 1     1 34.668595 31.41005 #> 2     2 15.300222 12.04168 #> 3     3 13.868300 10.60976 #> 4     4  3.258541  0.00000 #> 5     5 11.362061  8.10352"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Introduction","title":"EDMA form difference matrix","text":"tutorial explains calculate form difference based 2 EDMA data objects homologous landmarks. use 2 data sets: one without mutation responsible Crouzon syndrome:","code":"library(EDMAinR) #> EDMAinR 0.1-6     2020-10-01  file1 <- system.file(\"extdata/crouzon/Crouzon_P0_Global_MUT.xyz\",     package=\"EDMAinR\") x1 <- read_xyz(file1)  file2 <- system.file(\"extdata/crouzon/Crouzon_P0_Global_NON-MUT.xyz\",     package=\"EDMAinR\") x2 <- read_xyz(file2)"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Estimating the form matrices","title":"EDMA form difference matrix","text":"first estimate mean forms (bootstrap replicates necessary). Form matrices (\\(FM\\)) formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms objects \\(\\) \\(B\\).","code":"numerator <- edma_fit(x1, B=25) denominator <- edma_fit(x2, B=25)"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Form difference","title":"EDMA form difference matrix","text":"Form difference (\\(FDM\\)) calculated ratio form matrices (\\(FM\\)) numerator denominator objects following Lele Richtsmeier (1992, 1995): \\(FDM(,B) = FM(B)/FM()\\). Bootstrap distribution based fixing reference \\(FM\\) taking ratio reference \\(FM\\) bootstrap \\(FM\\)s object. ref_denom argument can used control object reference (denominator default), B number replicates drawn distribution:","code":"fdm <- edma_fdm(numerator, denominator, B=25) fdm #> EDMA form difference matrix #> Call: edma_fdm(numerator = numerator, denominator = denominator, B = 25) #> 25 bootstrap runs (ref: denominator) #> T = 1.5981, p < 2.22e-16"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Global T-test","title":"EDMA form difference matrix","text":"global T-test based pairwise distances \\(FM\\)s, taking max/min ratio distances. done B replicates, provides null distribution. \\(p\\) value T-test calculated number replicates bootstrap T value higher equal observed T value, divided B. T_test provides summary test, plot_Ttest helps visualize null distribution (histogram) observed T statistic (vertical line):","code":"T_test(fdm) #>  #>  Bootstrap based EDMA T-test #>  #> data:  form difference matrix #> T-value = 1.5981, B = 25, p-value < 2.2e-16 plot_Ttest(fdm)"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Local testing","title":"EDMA form difference matrix","text":"local testing done based confidence intervals using stacked \\(FDM\\)s bootstrap. Output structure similar output get_fm function, interpretation confidence intervals different due different nature bootstrap distribution. distribution characterizes \\(FDM\\) \\(FM\\). confidence level can changed level argument. Differences confidence limits indicate distances significantly deviate bootstrap based null expectation, thus related landmarks drive differences. Inspecting highest lowest differences (using sort) can help revealing landmarks. lower upper limits confidence intervals based confint (row names indicate unsorted sequence landmark pairs output get_fdm(fdm)): plot_ci function shows pairwise differences confidence intervals. x-axis label shows landmark pairs, gets really busy. Use xshow=FALSE argument remove labels.  can use stacked \\(FDM\\) data frame make ggplot2 based plot:","code":"head(get_fdm(fdm)) #>     row   col      dist     lower     upper #> 1   bas amsph 1.0425379 1.0291234 1.0572437 #> 2  cpsh amsph 0.9823765 0.9616780 0.9988809 #> 3 ethma amsph 1.0037761 0.9914403 1.0156289 #> 4 ethmp amsph 0.9401242 0.9278436 0.9510568 #> 5 laalf amsph 0.9878983 0.9788081 0.9990751 #> 6 lasph amsph 1.0161844 0.9891307 1.0317053 head(get_fdm(fdm, sort=TRUE, decreasing=TRUE)) #>       row   col     dist    lower    upper #> 136 ethmp ethma 1.377873 1.279108 1.479039 #> 697  rpto  lpto 1.131002 1.087753 1.164933 #> 179 laalf ethmp 1.095672 1.070444 1.124045 #> 200 raalf ethmp 1.094267 1.067043 1.125650 #> 881  rpmx raalf 1.080811 1.061278 1.103610 #> 607  rpns  lpns 1.078698 1.058532 1.122745 head(get_fdm(fdm, sort=TRUE, decreasing=FALSE)) #>        row   col      dist     lower     upper #> 527   lsqu  lpfl 0.8622059 0.8089977 0.9459507 #> 1022  rsqu  rpfl 0.8781312 0.8243285 0.9393457 #> 93   ethmp  cpsh 0.9034404 0.8810750 0.9250952 #> 212   rpsh ethmp 0.9177018 0.8965352 0.9395801 #> 190   lpsh ethmp 0.9181652 0.8947758 0.9348729 #> 4    ethmp amsph 0.9401242 0.9278436 0.9510568 head(confint(fdm)) #>                  2.5%     97.5% #> bas-amsph   1.0291234 1.0572437 #> cpsh-amsph  0.9616780 0.9988809 #> ethma-amsph 0.9914403 1.0156289 #> ethmp-amsph 0.9278436 0.9510568 #> laalf-amsph 0.9788081 0.9990751 #> lasph-amsph 0.9891307 1.0317053 plot_ci(fdm, xshow=FALSE) library(ggplot2) df <- get_fdm(fdm, sort=TRUE) df$x <- 1:nrow(df) p <- ggplot(data=df, aes(x=x, y=dist, ymin=lower, ymax=upper)) +   geom_ribbon(col=\"#0000ff40\", fill=\"#0000ff40\") +   geom_line() +   geom_hline(yintercept=1, col=2) +   labs(y=\"FDM Ratio\", x=\"Landmark Pairs\") +   theme_linedraw() +   theme(axis.text.x=element_blank()) p"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Influential landmarks","title":"EDMA form difference matrix","text":"can consider landmark influential respect form difference removing landmark, global T value moves close 1. case indicate landmark question driving form differences (.e. pairwise distances landmark landmarks contribute maximum value T statistic). , however, remove non-influential landmark, expect T value change lot. Therefore, ‘drop’ T value removing landmark can used rank landmarks based influence. Influential landmarks identified leaving one landmark time, calculating T-statistic based remaining distances. can use bootstrap distribution see T value ‘drop’ makes global test non-significant. means removing landmark, form difference distinguished null expectation. influential landmark one largest drop T value compared original T statistic. Tdrop newly calculated T value leaving landmark question: Note: used order function create index order rows infl data frame. get_influence also takes level argument specifying desired confidence interval (default 95%). plot function shows landmarks ordered Tdrop influential landmarks left-hand side plot. horizontal line top indicates original T value (landmarks considered), increasing line shows Tdrop, shaded area null distribution T statistic:  ggplot2 version:","code":"infl <- get_influence(fdm) head(infl[order(infl$Tdrop),], 10) #>    landmark    Tdrop    lower    upper #> 4     ethma 1.311754 1.074204 1.253519 #> 5     ethmp 1.311754 1.074204 1.253519 #> 14     lpfl 1.569097 1.074204 1.350022 #> 21     lsqu 1.569097 1.074204 1.350022 #> 1     amsph 1.598078 1.074204 1.360890 #> 2       bas 1.598078 1.074204 1.360890 #> 3      cpsh 1.598078 1.074204 1.360890 #> 6     laalf 1.598078 1.074204 1.360890 #> 7     lasph 1.598078 1.074204 1.360890 #> 8     lflac 1.598078 1.074204 1.360890 plot(infl) df <- infl[order(infl$Tdrop),] df$landmark <- factor(as.character(df$landmark), as.character(df$landmark)) p <- ggplot(data=df, aes(x=landmark, y=Tdrop, ymin=lower, ymax=upper, group=1)) +   geom_ribbon(col=\"#0000ff40\", fill=\"#0000ff40\") +   geom_hline(yintercept=T_test(fdm)$statistic, col=2) +   geom_line() +   labs(y=\"T-value\", x=\"Landmarks\") +   theme(axis.text.x=element_text(angle = 45,         vjust = 1, hjust=1)) p"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Ordination and clustering for specimens","title":"EDMA form difference matrix","text":"ordination cluster dendrogram shows two sets specimens 2 objects diagram. 2 sets combined combine_data function: visualization otherwise use principles described EDMA data objects. difference specimens labels colored (using default qualitative palette) according groups (numerator vs. denominator). numerator denominator objects different (global T value high, \\(p\\) value low, influential landmarks), expect two groups separate ordination space along dendrogram:  dendrogram leaves (specimen labels) also colored groups:  colors can changed via color options:","code":"x1 #> EDMA data: Crouzon P0 MUT #> 47 landmarks, 3 dimensions, 28 specimens x2 #> EDMA data: Crouzon P0 UNAFF #> 47 landmarks, 3 dimensions, 31 specimens (x12 <- combine_data(x1, x2)) #> EDMA data: data with 2 groups #> 47 landmarks, 3 dimensions, 59 specimens table(x12$groups) #>  #>  1  2  #> 28 31 plot_ord(fdm) plot_clust(fdm) op <- options(\"edma_options\" = list(     diverging = \"Blue-Red\",     qualitative = \"Warm\")) plot_ord(fdm) options(op)"},{"path":"/articles/edma04-form-difference.html","id":null,"dir":"Articles","previous_headings":"","what":"Visualizing landmarks","title":"EDMA form difference matrix","text":"2D 3D plots produce plot mean form reference object (‘prototype’). color intensity landmarks (dots) associated Tdrop influence value (larger difference, intensive color; red default). Lines landmarks represent distances. use diverging palettes: <1 differences colored blue (1st half palette), >1 differences colored red (2st half palette).  2D 3D plots display pairwise distances. displaying edges desired, use =TRUE argument.","code":"plot_2d(fdm, cex=2) library(rgl) xyz <- plot_3d(fdm) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/articles/edma04-growth.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"EDMA growth matrix","text":"tutorial explains calculate growth matrix based 4 EDMA data objects homologous landmarks. use data sets landmarks measured specimens 2 different ages (E17.5 embryonic newborn mice), taking subset (l) 10 landmarks:","code":"library(EDMAinR) #> EDMAinR 0.2-0     2021-11-04  file_a1 <- system.file(\"extdata/growth/CZEM_wt_global.xyz\",     package=\"EDMAinR\") file_a2 <- system.file(\"extdata/growth/CZP0_wt_global.xyz\",     package=\"EDMAinR\")  l <- c(\"amsph\", \"bas\", \"loci\", \"lpto\", \"lsqu\",         \"lsyn\", \"roci\", \"rpto\", \"rsqu\", \"rsyn\")  a1 <- read_xyz(file_a1)[l,,] a2 <- read_xyz(file_a2)[l,,] a1 #> EDMA data: Crouzon unaffected embryonic mouse #> 10 landmarks, 3 dimensions, 31 specimens a2 #> EDMA data: Crouzon unaffected newborn mouse #> 10 landmarks, 3 dimensions, 11 specimens"},{"path":"/articles/edma04-growth.html","id":"estimating-the-growth-matrices","dir":"Articles","previous_headings":"","what":"Estimating the growth matrices","title":"EDMA growth matrix","text":"first estimate mean forms (bootstrap replicates necessary). Growth matrices (\\(GM\\)) formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms objects a1 a2. growth matrix calculated ratio form matrices (\\(FM\\)) numerator denominator objects: \\(FDM(a1,a2) = FM(a2)/FM(a1)\\). a2 taken numerator, a1 denominator. put older sample (newborn) numerator spot younger sample (embryonic) denominator spot","code":"fit_a1 <- edma_fit(a1, B=25) fit_a2 <- edma_fit(a2, B=25) gm <- edma_gm(a1=fit_a1, a2=fit_a2, B=25) gm #> EDMA growth matrix #> Call: edma_gm(a1 = fit_a1, a2 = fit_a2, B = 25) #> 25 bootstrap runs (ref: denominator) #> Tobs = 1.259, p < 2.22e-16"},{"path":"/articles/edma04-growth.html","id":"global-t-test","dir":"Articles","previous_headings":"","what":"Global T-test","title":"EDMA growth matrix","text":"global testing explained form difference page:","code":"global_test(gm) #>  #>  Bootstrap based EDMA T-test #>  #> data:  growth matrix #> Tobs-value = 1.259, B = 25, p-value < 2.2e-16 plot_Ttest(gm)"},{"path":"/articles/edma04-growth.html","id":"local-testing","dir":"Articles","previous_headings":"","what":"Local testing","title":"EDMA growth matrix","text":"local testing explained form difference page: plot_ci function shows pairwise differences confidence intervals:","code":"head(confint(gm)) #>                2.5%    97.5% #> bas-amsph  1.097126 1.139303 #> loci-amsph 1.090709 1.140518 #> lpto-amsph 1.124263 1.157854 #> lsqu-amsph 1.125901 1.180991 #> lsyn-amsph 1.111795 1.183497 #> roci-amsph 1.088908 1.140621 head(get_gm(gm)) #>    row   col     dist    lower    upper #> 1  bas amsph 1.116726 1.097126 1.139303 #> 2 loci amsph 1.112833 1.090709 1.140518 #> 3 lpto amsph 1.144189 1.124263 1.157854 #> 4 lsqu amsph 1.149705 1.125901 1.180991 #> 5 lsyn amsph 1.139680 1.111795 1.183497 #> 6 roci amsph 1.110515 1.088908 1.140621 head(get_gm(gm, sort=TRUE, decreasing=TRUE)) #>     row  col     dist    lower    upper #> 45 rsyn rsqu 1.196344 1.170451 1.221840 #> 31 lsyn lsqu 1.194661 1.171932 1.222121 #> 41 rsqu roci 1.159037 1.138248 1.190256 #> 35 rsyn lsqu 1.155865 1.132506 1.183046 #> 19 lsqu loci 1.155629 1.133975 1.179900 #> 16 rsqu  bas 1.155440 1.135015 1.177115 head(get_gm(gm, sort=TRUE, decreasing=FALSE)) #>     row  col      dist     lower    upper #> 28 rpto lpto 0.9502249 0.9187017 1.017281 #> 34 rsqu lsqu 1.0364970 1.0186496 1.062037 #> 21 roci loci 1.0365211 1.0021116 1.055886 #> 27 roci lpto 1.0423805 1.0296007 1.062666 #> 22 rpto loci 1.0515532 1.0381430 1.070109 #> 29 rsqu lpto 1.0610708 1.0388944 1.082089 plot_ci(gm)"},{"path":"/articles/edma04-growth.html","id":"influential-landmarks","dir":"Articles","previous_headings":"","what":"Influential landmarks","title":"EDMA growth matrix","text":"Influence calculated similarly \\(FDM\\):","code":"get_influence(gm) #>    landmark    Tdrop    lower    upper #> 1     amsph 1.259012 1.012273 1.147487 #> 2       bas 1.259012 1.015448 1.147487 #> 3      loci 1.259012 1.015448 1.147487 #> 4      lpto 1.154219 1.012714 1.090116 #> 5      lsqu 1.259012 1.011701 1.147487 #> 6      lsyn 1.259012 1.015448 1.146744 #> 7      roci 1.259012 1.014498 1.147487 #> 8      rpto 1.154219 1.010438 1.079035 #> 9      rsqu 1.257240 1.013524 1.146822 #> 10     rsyn 1.257240 1.012347 1.146079 plot(get_influence(gm))"},{"path":"/articles/edma04-growth.html","id":"ordination-and-clustering-for-specimens","dir":"Articles","previous_headings":"","what":"Ordination and clustering for specimens","title":"EDMA growth matrix","text":"dendrogram leaves (specimen labels) also colored groups:","code":"plot_ord(gm) plot_clust(gm)"},{"path":"/articles/edma04-growth.html","id":"visualizing-landmarks","dir":"Articles","previous_headings":"","what":"Visualizing landmarks","title":"EDMA growth matrix","text":"2D 3D plots produce plot mean form reference object (‘prototype’). color intensity landmarks (dots) associated Tdrop influence value (larger difference, intensive color; red default). Lines landmarks represent distances. use diverging palettes: <1 differences colored blue (1st half palette), >1 differences colored red (2st half palette).","code":"plot_2d(gm, cex=2) library(rgl) xyz <- plot_3d(gm) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/articles/edma04-growth.html","id":"growth-difference-matrix","dir":"Articles","previous_headings":"","what":"Growth difference matrix","title":"EDMA growth matrix","text":"Growth difference matrix (\\(GDM\\)) calculated \\(GDM(A1,A2,B1,B2) = GM(B1,B2) / GM(A1,A2)\\). use two Crouzon mutant samples, age groups unaffected samples (embryonic newborn): Growth matrices (\\(GM\\)) formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms objects a1 a2. growth matrix calculated ratio form matrices (\\(FM\\)) numerator denominator objects: \\(FDM(a1,a2) = FM(a2)/FM(a1)\\). a2 taken numerator, a1 denominator. put older sample (newborn) numerator spot younger sample (embryonic) denominator spot","code":"file_b1 <- system.file(\"extdata/growth/CZEM_mut_global.xyz\",     package=\"EDMAinR\") file_b2 <- system.file(\"extdata/growth/CZP0_mut_global.xyz\",     package=\"EDMAinR\")  b1 <- read_xyz(file_b1)[l,,] b2 <- read_xyz(file_b2)[l,,] b1 #> EDMA data: Crouzon mutant embryonic mouse #> 10 landmarks, 3 dimensions, 18 specimens b2 #> EDMA data: Crouzon mutant newborn mouse #> 10 landmarks, 3 dimensions, 11 specimens  fit_b1 <- edma_fit(b1, B=25) fit_b2 <- edma_fit(b2, B=25) gdm <- edma_gdm(a1=fit_a1, a2=fit_a2, b1=fit_b1, b2=fit_b2, B=25) gdm #> EDMA growth difference matrix #> Call: edma_gdm(a1 = fit_a1, a2 = fit_a2, b1 = fit_b1, b2 = fit_b2,  #>     B = 25) #> 25 bootstrap runs (ref: denominator) #> Tobs = 1.1113, p = 0.15385  global_test(gdm) #>  #>  Bootstrap based EDMA T-test #>  #> data:  growth difference matrix #> Tobs-value = 1.1113, B = 26, p-value = 0.1538 plot_Ttest(gdm) plot_ci(gdm) plot_ord(gdm) plot_clust(gdm) plot_2d(gdm) xyz <- plot_3d(gdm) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Introduction","title":"EDMA growth matrix","text":"tutorial explains calculate growth matrix based 2 EDMA data objects homologous landmarks. use data sets landmarks measured specimens 2 different ages (E17.5 embryonic newborn mice), taking subset (l) 10 landmarks:","code":"library(EDMAinR) #> EDMAinR 0.1-6     2020-10-01  file_a1 <- system.file(\"extdata/growth/CZEM_wt_global.xyz\",     package=\"EDMAinR\") file_a2 <- system.file(\"extdata/growth/CZP0_wt_global.xyz\",     package=\"EDMAinR\")  l <- c(\"amsph\", \"bas\", \"loci\", \"lpto\", \"lsqu\",         \"lsyn\", \"roci\", \"rpto\", \"rsqu\", \"rsyn\")  a1 <- read_xyz(file_a1)[l,,] a2 <- read_xyz(file_a2)[l,,] a1 #> EDMA data: Crouzon unaffected embryonic mouse #> 10 landmarks, 3 dimensions, 31 specimens a2 #> EDMA data: Crouzon unaffected newborn mouse #> 10 landmarks, 3 dimensions, 11 specimens"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Estimating the growth matrices","title":"EDMA growth matrix","text":"first estimate mean forms (bootstrap replicates necessary). Growth matrices (\\(GM\\)) formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms objects a1 a2. growth matrix calculated ratio form matrices (\\(FM\\)) numerator denominator objects: \\(FDM(a1,a2) = FM(a2)/FM(a1)\\). a2 taken numerator, a1 denominator. put older sample (newborn) numerator spot younger sample (embryonic) denominator spot","code":"fit_a1 <- edma_fit(a1, B=25) fit_a2 <- edma_fit(a2, B=25) gm <- edma_gm(a1=fit_a1, a2=fit_a2, B=25) gm #> EDMA growth matrix #> Call: edma_gm(a1 = fit_a1, a2 = fit_a2, B = 25) #> 25 bootstrap runs (ref: denominator) #> T = 1.259, p < 2.22e-16"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Global T-test","title":"EDMA growth matrix","text":"global T-test based pairwise distances \\(FM\\)s, taking max/min ratio distances. done B replicates, provides null distribution. \\(p\\) value T-test calculated number replicates bootstrap T value higher equal observed T value, divided B. T_test provides summary test, plot_Ttest helps visualize null distribution (histogram) observed T statistic (vertical line):","code":"T_test(gm) #>  #>  Bootstrap based EDMA T-test #>  #> data:  growth matrix #> T-value = 1.259, B = 25, p-value < 2.2e-16 plot_Ttest(gm)"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Local testing","title":"EDMA growth matrix","text":"local testing done based confidence intervals using stacked \\(GM\\)s bootstrap. distribution characterizes \\(GM\\) \\(FM\\). confidence level can changed level argument. plot_ci function shows pairwise differences confidence intervals:","code":"head(confint(gm)) #>                2.5%    97.5% #> bas-amsph  1.097126 1.139303 #> loci-amsph 1.090709 1.140518 #> lpto-amsph 1.124263 1.157854 #> lsqu-amsph 1.125901 1.180991 #> lsyn-amsph 1.111795 1.183497 #> roci-amsph 1.088908 1.140621 head(get_gm(gm)) #>    row   col     dist    lower    upper #> 1  bas amsph 1.116726 1.097126 1.139303 #> 2 loci amsph 1.112833 1.090709 1.140518 #> 3 lpto amsph 1.144189 1.124263 1.157854 #> 4 lsqu amsph 1.149705 1.125901 1.180991 #> 5 lsyn amsph 1.139680 1.111795 1.183497 #> 6 roci amsph 1.110515 1.088908 1.140621 head(get_gm(gm, sort=TRUE, decreasing=TRUE)) #>     row  col     dist    lower    upper #> 45 rsyn rsqu 1.196344 1.170451 1.221840 #> 31 lsyn lsqu 1.194661 1.171932 1.222121 #> 41 rsqu roci 1.159037 1.138248 1.190256 #> 35 rsyn lsqu 1.155865 1.132506 1.183046 #> 19 lsqu loci 1.155629 1.133975 1.179900 #> 16 rsqu  bas 1.155440 1.135015 1.177115 head(get_gm(gm, sort=TRUE, decreasing=FALSE)) #>     row  col      dist     lower    upper #> 28 rpto lpto 0.9502249 0.9187017 1.017281 #> 34 rsqu lsqu 1.0364970 1.0186496 1.062037 #> 21 roci loci 1.0365211 1.0021116 1.055886 #> 27 roci lpto 1.0423805 1.0296007 1.062666 #> 22 rpto loci 1.0515532 1.0381430 1.070109 #> 29 rsqu lpto 1.0610708 1.0388944 1.082089 plot_ci(gm)"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Influential landmarks","title":"EDMA growth matrix","text":"Influence calculated similarly \\(FDM\\):","code":"get_influence(gm) #>    landmark    Tdrop    lower    upper #> 1     amsph 1.259012 1.012273 1.147487 #> 2       bas 1.259012 1.015448 1.147487 #> 3      loci 1.259012 1.015448 1.147487 #> 4      lpto 1.154219 1.012714 1.090116 #> 5      lsqu 1.259012 1.011701 1.147487 #> 6      lsyn 1.259012 1.015448 1.146744 #> 7      roci 1.259012 1.014498 1.147487 #> 8      rpto 1.154219 1.010438 1.079035 #> 9      rsqu 1.257240 1.013524 1.146822 #> 10     rsyn 1.257240 1.012347 1.146079 plot(get_influence(gm))"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Ordination and clustering for specimens","title":"EDMA growth matrix","text":"dendrogram leaves (specimen labels) also colored groups:","code":"plot_ord(gm) plot_clust(gm)"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Visualizing landmarks","title":"EDMA growth matrix","text":"2D 3D plots produce plot mean form reference object (‘prototype’). color intensity landmarks (dots) associated Tdrop influence value (larger difference, intensive color; red default). Lines landmarks represent distances. use diverging palettes: <1 differences colored blue (1st half palette), >1 differences colored red (2st half palette).","code":"plot_2d(gm, cex=2) library(rgl) xyz <- plot_3d(gm) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/articles/edma05-growth.html","id":null,"dir":"Articles","previous_headings":"","what":"Growth difference matrix","title":"EDMA growth matrix","text":"Growth difference matrix (\\(GDM\\)) calculated \\(GDM(A1,A2,B1,B2) = GM(B1,B2) / GM(A1,A2)\\). use two Crouzon mutant samples, age groups unaffected samples (embryonic newborn): Growth matrices (\\(GM\\)) formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms objects a1 a2. growth matrix calculated ratio form matrices (\\(FM\\)) numerator denominator objects: \\(FDM(a1,a2) = FM(a2)/FM(a1)\\). a2 taken numerator, a1 denominator. put older sample (newborn) numerator spot younger sample (embryonic) denominator spot","code":"file_b1 <- system.file(\"extdata/growth/CZEM_mut_global.xyz\",     package=\"EDMAinR\") file_b2 <- system.file(\"extdata/growth/CZP0_mut_global.xyz\",     package=\"EDMAinR\")  b1 <- read_xyz(file_b1)[l,,] b2 <- read_xyz(file_b2)[l,,] b1 #> EDMA data: Crouzon mutant embryonic mouse #> 10 landmarks, 3 dimensions, 18 specimens b2 #> EDMA data: Crouzon mutant newborn mouse #> 10 landmarks, 3 dimensions, 11 specimens  fit_b1 <- edma_fit(b1, B=25) fit_b2 <- edma_fit(b2, B=25) gdm <- edma_gdm(a1=fit_a1, a2=fit_a2, b1=fit_b1, b2=fit_b2, B=25) gdm #> EDMA growth difference matrix #> Call: edma_gdm(a1 = fit_a1, a2 = fit_a2, b1 = fit_b1, b2 = fit_b2,  #>     B = 25) #> 25 bootstrap runs (ref: denominator) #> T = 1.1113, p = 0.15385  T_test(gdm) #>  #>  Bootstrap based EDMA T-test #>  #> data:  growth difference matrix #> T-value = 1.1113, B = 26, p-value = 0.1538 plot_Ttest(gdm) plot_ci(gdm) plot_ord(gdm) plot_clust(gdm) plot_2d(gdm) xyz <- plot_3d(gdm) text3d(xyz, texts=rownames(xyz), pos=1) # this adds names decorate3d() # this adds the axes rglwidget(width = 600, height = 600, reuse = FALSE)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors","text":"Peter Solymos. Author, maintainer. Subhash R. Lele. Author. Theodore M. Cole. Author. Liangyuan Hu. Author. Joan T. Richtsmeier. Author.","code":""},{"path":"/index.html","id":"edmainr---euclidean-distance-matrix-analysis-in-r","dir":"","previous_headings":"","what":"Euclidean Distance Matrix Analysis in R","title":"Euclidean Distance Matrix Analysis in R","text":"coordinate‐free approach comparing biological shapes using landmark data","code":""},{"path":"/index.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"Euclidean Distance Matrix Analysis in R","text":"See new NEWS file.","code":"if (!require(\"remotes\")) install.packages(\"remotes\") remotes::install_github(\"psolymos/EDMAinR\")"},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Euclidean Distance Matrix Analysis in R","text":"GPL-2","code":""},{"path":"/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Euclidean Distance Matrix Analysis in R","text":"Feedback contributions welcome: submit feature request report issues , fork project submit pull request, see CoC.","code":""},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Euclidean Distance Matrix Analysis in R","text":"","code":"library(EDMAinR) #> EDMAinR 0.1-3     2020-06-12  file1 <- system.file(\"extdata/crouzon/Crouzon_P0_Global_MUT.xyz\",     package=\"EDMAinR\") x1 <- read_xyz(file1) x1 #> EDMA data: Crouzon P0 MUT #> 3 dimensions, 47 landmarks, 28 specimens  file2 <- system.file(\"extdata/crouzon/Crouzon_P0_Global_NON-MUT.xyz\",     package=\"EDMAinR\") x2 <- read_xyz(file2) x2 #> EDMA data: Crouzon P0 UNAFF #> 3 dimensions, 47 landmarks, 31 specimens  B <- 9  fit <- edma_fit(x1, B=B) fit #> EDMA nonparametric fit: Crouzon P0 MUT #> Call: edma_fit(x = x1, B = B) #> 3 dimensions, 47 landmarks, 28 replicates, 9 bootstrap runs"},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Euclidean Distance Matrix Analysis in R","text":"Lele, S. R., 1991. comments coordinate-free scale-invariant methods morphometrics. American Journal Physical Anthropology 85:407–417. doi:10.1002/ajpa.1330850405 Lele, S. R., Richtsmeier, J. T., 1991. Euclidean distance matrix analysis: coordinate-free approach comparing biological shapes using landmark data. American Journal Physical Anthropology 86(3):415–27. doi:10.1002/ajpa.1330860307 Lele, S. R., Richtsmeier, J. T., 1992. comparing biological shapes: detection influential landmarks. American Journal Physical Anthropology 87:49–65. doi:10.1002/ajpa.1330870106 Lele, S. R., Richtsmeier, J. T., 1995. Euclidean distance matrix analysis: confidence intervals form growth differences. American Journal Physical Anthropology 98:73–86. doi:10.1002/ajpa.1330980107 Hu, L., 2007. Euclidean Distance Matrix Analysis Landmarks Data: Estimation Variance. Thesis, Master Science Statistics, Department Mathematical Statistical Sciences, University Alberta, Edmonton, Alberta, Canada. Pp. 49.","code":""},{"path":"/reference/edma_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and manipulate colors — edma_colors","title":"Check and manipulate colors — edma_colors","text":"Check manipulate default color values.","code":""},{"path":"/reference/edma_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Check and manipulate colors — edma_colors","text":"","code":"edma_colors(n,     type=c(\"diverging\", \"sequential\", \"qualitative\"),     alpha=1, rev=FALSE)  plot_edma_colors(n=9, maxq=9)"},{"path":"/reference/edma_colors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and manipulate colors — edma_colors","text":"n number colors (>0) palette. type type palette. alpha alpha transparency, number [0,1]. rev logical, colors reversed. maxq maximum number qualitative colors plot.","code":""},{"path":"/reference/edma_colors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check and manipulate colors — edma_colors","text":"edma_colors create vector n colors based settings getOption(\"edma_options\"). options can set via options (see Examples). options can either name palette hcl.colors. option set multiple values, treated colors interplolated colorRampPalette. qualitative palettes, color values used directly (recycled needed). Sequential palettes produced higher half diverging palette consistency.","code":""},{"path":"/reference/edma_colors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and manipulate colors — edma_colors","text":"edma_colors returns vector hax color codes, plot_edma_colors produces plot diverging, sequential, qualitative default palettes given settings getOption(\"edma_options\").","code":""},{"path":"/reference/edma_colors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check and manipulate colors — edma_colors","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/edma_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions for EDMA data objects — edma_data","title":"Functions for EDMA data objects — edma_data","text":"Functions reading, simulating, manipulating EDMA data.","code":""},{"path":"/reference/edma_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Functions for EDMA data objects — edma_data","text":"","code":"## read xyz files read_xyz(file, ...)  ## write xyz files write_xyz(x, file)  ## data generation edma_simulate_data(n, M, SigmaK)  ## print # S3 method for edma_data print(x, truncate=40, ...)  ## accessors # S3 method for edma_data dim(x) # S3 method for edma_data dimnames(x) landmarks(x, ...) dimensions(x, ...) specimens(x, ...) # S3 method for edma_data landmarks(x, ...) # S3 method for edma_data dimensions(x, ...) # S3 method for edma_data specimens(x, ...) landmarks(x) <- value dimensions(x) <- value specimens(x) <- value  ## subsetting # S3 method for edma_data subset(x, subset, ...) # S3 method for edma_data [(x, i, j, k)  ## coercion # S3 method for edma_data stack(x, ...) # S3 method for edma_data as.matrix(x, ...) # S3 method for edma_data as.data.frame(x, ...) # S3 method for edma_data as.array(x, ...) as.edma_data(x, ...) # S3 method for array as.edma_data(x, ...)  combine_data(a, b,     ga=\"G1\", gb=\"G2\") combine_data4(a1, a2, b1, b2,     ga1=\"A1\", ga2=\"A2\", gb1=\"B1\", gb2=\"B2\")  ## plot methods plot_2d(x, ...) plot_ord(x, ...) plot_clust(x, ...) # S3 method for edma_data plot(x, which=NULL,     ask=dev.interactive(), ...) # S3 method for edma_data plot_2d(x, which=NULL, ...) # S3 method for edma_data plot_ord(x, ...) # S3 method for edma_data plot_clust(x, ...)  ## dissimilarities # S3 method for edma_data as.dist(m, diag=FALSE, upper=FALSE)"},{"path":"/reference/edma_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions for EDMA data objects — edma_data","text":"file name file data read , written , see read.table details. x, m EDMA data object class 'edma_data'. subset specimens required. value possible value dimnames(x). ask logical, TRUE, user asked plot. subset, , j, k subset subsetting specimens (e.g. bootstrap). [, j, k] indices refer [landmarks, dimensions, specimens]. n, M, SigmaK number specimens (n), mean form matrix (M, K x D), variance-covariance matrix (K x K symmetric). truncate numeric, number characters print object title. diag, upper logical, indicating whether diagonal upper triangle distance matrix printed. See .dist. , b, a1, a2, b1, b2 EDMA data objects combined together. Landmarks must homologous (determined dimension names). ga, gb, ga1, ga2, gb1, gb2 character, group names prepended specimen names differentiate groups. ... arguments passed methods. read_xyz, arguments passed read.table.","code":""},{"path":"/reference/edma_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions for EDMA data objects — edma_data","text":"xyz landmark data following structure, see Examples: - Header: description data. - XYZ: indicates dimensions, XYZ means 3D landmark data. - 42L 3 9: dimensions, e.g. 42 landmarks (K), 3 dimensions (D), 9 specimens (n). - Landmark names, separated space. - stacked data landmark coordinates, e.g. 3 columns, space separated numeric values K*n rows, K landmarks per individuals stacked n times. - Blank line. - Date scans specimen (n rows), part also used get specimen IDs. reading simulating EDMA data object, methods help extracting info, manipulate objects. See Values Examples. EDMA data object (class 'edma_data') list two elements: $name data set name (header information .xyz file), $data list n matrices (list can named speciemen information present), matrix dimension K x D, dimension names matrices describing landmark names coordinate names.","code":""},{"path":"/reference/edma_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions for EDMA data objects — edma_data","text":"edma_simulate_data returns EDMA data object class 'edma_data'. dim returns number landmarks (K), dimensions (D), specimens (n) data object. landmarks, dimensions, specimensare dimensions names, dimnames returns list. Landmark names dimensions used check landmarks homogeneous among objects. possible set dimansion names dimnames(x) <- value value new value name. print method prints info data object. methods stack .matrix return stacked 2D array (K*n x D) landmark coordinates, .data.frame turns 2D stacked array data frame, .array returns 3D array (K x D x n). .edma_data turns 3D array EDMA data object, useful handle 3D array objects returned many functions geomorph package (.e. reding Morphologika, NTS, TPS files). combine_data combine_data4 combines 2 4 EDMA data sets together, landmarks must homologous. .dist calculates dissimilarity matrix (n x n, object class 'dist', see dist) containing pairwise dissimilarities among specimens. Dissimilarity based T-statistic (max/min distance) averaged (symmetric) log scale (self dissimilarity 0). subset [,j,k] returns EDMA data object desired dimensions permutations. See Examples. plot plot_2d produces series plots side effect, returning data object invisibly. functions provide diagnostics specimen just specimen selected argument. 2D projection used case 3D landmark data. convex hull specimens (excluding one selected) compared actual specimen's landmarks. allows easy spotting erroneous data. plot_ord plot_clust based dissimilarities among specimens provide ordination (metric multidimensional scaling using cmdscalebased square rooted dissimilarities Cailliez's correction). hierarchical cluster dendrogram (using hclustfunction Ward's clustering method).","code":""},{"path":"/reference/edma_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functions for EDMA data objects — edma_data","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/edma_fdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Form difference — edma_fdm","title":"Form difference — edma_fdm","text":"Form difference matrix based inference based Lele Richtsmeier (1992, 1995).","code":""},{"path":"/reference/edma_fdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Form difference — edma_fdm","text":"","code":"edma_fdm(numerator, denominator,   B=0, ref_denom=TRUE, mix=FALSE)  get_influence(object, ...) # S3 method for edma_dm get_influence(object, level=0.95, ...) # S3 method for edma_influence plot(x, ...)  get_fdm(object, ...) # S3 method for edma_fdm get_fdm(object, sort=FALSE, level=0.95,     what=\"all\", ...) global_test(object, ...) # S3 method for edma_fdm global_test(object, ...) # S3 method for edma_dm confint(object, parm, level=0.95, ...)  # S3 method for edma_fdm print(x, ...) # S3 method for edma_fdm landmarks(x, ...) # S3 method for edma_fdm dimensions(x, ...)  plot_ci(x, ...) plot_Ttest(x, ...) # S3 method for edma_dm plot(x, ...) # S3 method for edma_dm plot_2d(x, ...) # S3 method for edma_dm plot_3d(x, ...) # S3 method for edma_dm plot_Ttest(x, ...) # S3 method for edma_fdm plot_ci(x, ...) # S3 method for edma_fdm plot_ord(x, ...) # S3 method for edma_fdm plot_clust(x, ...)"},{"path":"/reference/edma_fdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Form difference — edma_fdm","text":"numerator, denominator EDMA fit object compare forms. B nonnegative integer, number bootstrap replicates. ref_denom logical, TRUE, denominator used reference object (form matrix fixed calculating bootstrap comparing object). mix logical, use mixed bootstrap (numerator denominator populations mixed replacement) (non-reference population resampled replacement, reference fixed). x, object EDMA FDM object class 'edma_fdm'. sort logical, stacked distances sorted, see Examples. level numeric, 0 1, alpha level confidence interval. parm specification parameters given confidence intervals, either vector numbers vector names. See confint. part ford differences return: \"\", \"less\" \"greater\" 1, \"signif\" \"nonsignif\". ... arguments passed methods.","code":""},{"path":"/reference/edma_fdm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Form difference — edma_fdm","text":"Form difference (FDM) calculated ratio form matrices (FM) numerator denominator objects following Lele Richtsmeier (1992, 1995): FDM(,B) = FM(B)/FM(). Form matrices formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms. Bootstrap distribution based either 'mixed' mixed bootstrap distribution. 'mixed' bootstrap means bootstrap distribution represents n1+n2 specimens pooled sample numerator denominator populations. default mix=FALSE case fix reference FM taking ratio reference FM bootstrap FMs non-reference object (depending ref_denom argument). T-statistic based pairwise distanced FM, taking max/min distances. Confidence intervals local testing (via confint, get_fdm, plot_ci) T-test global testing (via global_test, plot_Ttest) based observed T-statistic bootstrap distribution. global testing algorithm follows: Suppose population 1 'reference' population. Step 1: Resample n1 observations first sample compute FM1*. Step 2: Resample n2 observations first sample compute FM2*. Step 3: Compute FDM* = FM2*/FM1* T* = max(FDM*)/min(FDM*) Step 4: Repeat three steps B times get p-value. Local testing (CI: confidence interval calculation) elements FDM based following algorithm: Step 1: Resample n1 observations first sample compute FM1*. Step 2: Resample n2 observations second sample compute FM2*. Step 3: Compute FDM* = FM2*/FM1* Step 4: Repeat three steps B times get confidence intervals elements FDM. Influential landmarks identified leaving one landmark , comparing T-statistic value based landmarks. existing bootstrap distribution mean form used (.e. re-estimation mean form) get_influence.","code":""},{"path":"/reference/edma_fdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Form difference — edma_fdm","text":"edma_fdm compares two EDMA fit objects calculates form difference. confint returns confidence intervals FDM, get_fdm extract stacked FDM confidence intervals, plot_ci visualizes ordered form differences confidence intervals. get_influence extracts landmark influence information, plot method visualizes . global_test presents global T-test, bootstrap distribution observed T-value visualized plot_Ttest. plot plot_2d produces 2D plot mean form reference object ('prototype'). plot_3d use rgl package make 3D plot using mean form. Influential landmarks colored red. Lines represent distances landmarks, <1 differences colored blue, >1 differences colored red. plot_ord plot_clustproduce plots based dissimilarities among specimens two objects.","code":""},{"path":"/reference/edma_fdm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Form difference — edma_fdm","text":"Lele, S. R., Richtsmeier, J. T., 1992. comparing biological shapes: detection influential landmarks. American Journal Physical Anthropology 87:49--65. <doi:10.1002/ajpa.1330870106> Lele, S. R., Richtsmeier, J. T., 1995. Euclidean distance matrix analysis: confidence intervals form growth differences. American Journal Physical Anthropology 98:73--86. <doi:10.1002/ajpa.1330980107>","code":""},{"path":"/reference/edma_fdm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Form difference — edma_fdm","text":"Peter Solymos, Subhash R. Lele, Theodore M. Cole, Joan T. Richtsmeier","code":""},{"path":[]},{"path":"/reference/edma_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric EDMA fit — edma_fit","title":"Nonparametric EDMA fit — edma_fit","text":"Estimate mean form SigmaKstar matrix based Lele (1991), Lele Richtsmeier (1991) Hu (2007).","code":""},{"path":"/reference/edma_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric EDMA fit — edma_fit","text":"","code":"edma_fit(x, B=0, ncores=getOption(\"Ncpus\", 1L))  ## generics Meanform(object, ...) SigmaKstar(object, ...) get_fm(object, ...)  ## methods # S3 method for edma_fit_np print(x, truncate=40, ...) # S3 method for edma_fit Meanform(object, ...) # S3 method for edma_fit SigmaKstar(object, ...) # S3 method for edma_fit get_fm(object, sort=FALSE, level=0.95, ...) # S3 method for edma_fit confint(object, parm, level=0.95, ...) # S3 method for edma_fit as.edma_data(x, ...)  ## plot methods plot_3d(x, ...) # S3 method for edma_fit plot(x, ...) # S3 method for edma_fit plot_2d(x, ...) # S3 method for edma_fit plot_3d(x, ...) # S3 method for edma_fit plot_ord(x, ...) # S3 method for edma_fit plot_clust(x, ...)  ## distance manipulation # S3 method for edma_fit as.dist(m, diag=FALSE, upper=FALSE) # S3 method for dist stack(x, ...)"},{"path":"/reference/edma_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric EDMA fit — edma_fit","text":"x, object, m EDMA data object class 'edma_data'. B nonnegative integer, number bootstrap replicates. ncores positive integer, number cores use bootstrapping. Use options(Ncpus = 2) set 2 globally. truncate numeric, number characters print object title. sort logical, stacked distances sorted, see Examples. level numeric, 0 1, alpha level confidence interval. parm specification parameters given confidence intervals, either vector numbers vector names. See confint. diag, upper logical, indicating whether diagonal upper triangle distance matrix printed. See .dist. ... arguments passed methods. E.g. plot_clust, method describing clustering agglomeration method used link{hclust} function (default \"ward.D2\").","code":""},{"path":"/reference/edma_fit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nonparametric EDMA fit — edma_fit","text":"function estimates mean form SigmaKstar matrix based Lele (1991), Lele Richtsmeier (1991) Hu (2007).","code":""},{"path":"/reference/edma_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric EDMA fit — edma_fit","text":"edma_fit returns EDMA fit object class 'edma_fit'. .edma_fit_np workhorse function behind edma_fit. stack.dist takes distance matrix class 'dist' turns long form data frame columns row col indicating row column labels, dist giving value cell. returns values lower triangle matrix. get_fm intended user interface extract form matrix (FM) EDMA fit objects. stacked distances based mean form. object bootstrap replicates, get_fm also returns confidence intervals distances based bootstrap confint method. Meanform extracts mean form (K x D) matrix, SigmaKstar extracts corresponding uncertainties (K x K) based EDMA fit object. plot plot_2d produces 2D plot mean form. 2D projection used case 3D landmark data based metric multidimensional scaling. plot_3d use rgl package make 3D plot. sizes dots correspond square root SigmaKstar diagonal elements. plot_ord plot_clustproduce plots based dissimilarities among specimens, see plot_ord.edma_data details.","code":""},{"path":"/reference/edma_fit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nonparametric EDMA fit — edma_fit","text":"Lele, S. R., 1991. comments coordinate-free scale-invariant methods morphometrics. American Journal Physical Anthropology 85:407--417. <doi:10.1002/ajpa.1330850405> Lele, S. R., Richtsmeier, J. T., 1991. Euclidean distance matrix analysis: coordinate-free approach comparing biological shapes using landmark data. American Journal Physical Anthropology 86(3):415--27. <doi:10.1002/ajpa.1330860307> Hu, L., 2007. Euclidean Distance Matrix Analysis Landmarks Data: Estimation Variance. Thesis, Master Science Statistics, Department Mathematical Statistical Sciences, University Alberta, Edmonton, Alberta, Canada. Pp. 49.","code":""},{"path":"/reference/edma_fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Nonparametric EDMA fit — edma_fit","text":"Peter Solymos, Subhash R. Lele, Theodore M. Cole, Liangyuan Hu, Joan T. Richtsmeier","code":""},{"path":[]},{"path":"/reference/edma_gdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Growth difference — edma_gdm","title":"Growth difference — edma_gdm","text":"Growth matrix growth difference matrix based inference based Lele Richtsmeier (1992, 1995).","code":""},{"path":"/reference/edma_gdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Growth difference — edma_gdm","text":"","code":"edma_gm(a1, a2, ...) get_gm(object, ...) # S3 method for edma_gm get_gm(object, sort=FALSE, level=0.95,     what=\"all\", ...)  edma_gdm(a1, a2, b1, b2, ...) get_gdm(object, ...) # S3 method for edma_gdm get_gdm(object, sort=FALSE, level=0.95,     what=\"all\", ...)  # S3 method for edma_gm print(x, ...) # S3 method for edma_gdm print(x, ...) # S3 method for edma_gm global_test(object, ...) # S3 method for edma_gdm global_test(object, ...) # S3 method for edma_gdm landmarks(x, ...) # S3 method for edma_gdm dimensions(x, ...)  # S3 method for edma_gdm plot_ord(x, ...) # S3 method for edma_gdm plot_clust(x, ...)"},{"path":"/reference/edma_gdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Growth difference — edma_gdm","text":"a1, a2, b1, b2 EDMA fit object compare growths. x, object EDMA GM GDM objects. sort logical, stacked distances sorted, see Examples. level numeric, 0 1, alpha level confidence interval. part ford differences return: \"\", \"less\" \"greater\" 1, \"signif\" \"nonsignif\". ... arguments passed edma_fdm, like ref_denom.","code":""},{"path":"/reference/edma_gdm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Growth difference — edma_gdm","text":"Growth matrix (GM) calculated ratio form matrices (FM) numerator denominator objects following Lele Richtsmeier (1992, 1995): GM(A1,A2) = FM(A2)/FM(A1). Form matrices formed pairwise Euclidean distances landmarks EDMA fit objects using estimated mean forms. Growth difference matrix (GDM) calculated GDM(A1,A2,B1,B2) = GM(B1,B2) / GM(A1,A2). Inference visualization similar done FDMs.","code":""},{"path":"/reference/edma_gdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Growth difference — edma_gdm","text":"edma_gm compares two EDMA fit objects calculates GM. edma_gdm compares 4 EDMA fit objects calculates GDM. plot_ord plot_clustproduce plots based dissimilarities among specimens 2 4 objects (GM GDM, respectively).","code":""},{"path":"/reference/edma_gdm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Growth difference — edma_gdm","text":"Lele, S. R., Richtsmeier, J. T., 1992. comparing biological shapes: detection influential landmarks. American Journal Physical Anthropology 87:49--65. <doi:10.1002/ajpa.1330870106> Lele, S. R., Richtsmeier, J. T., 1995. Euclidean distance matrix analysis: confidence intervals form growth differences. American Journal Physical Anthropology 98:73--86. <doi:10.1002/ajpa.1330980107>","code":""},{"path":"/reference/edma_gdm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Growth difference — edma_gdm","text":"Peter Solymos, Subhash R. Lele, Theodore M. Cole, Joan T. Richtsmeier","code":""},{"path":[]},{"path":"/reference/edma_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Shape difference — edma_sdm","title":"Shape difference — edma_sdm","text":"Shape difference matrix based inference following Lele Cole (1996).","code":""},{"path":"/reference/edma_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Shape difference — edma_sdm","text":"","code":"edma_sdm(a, b, log=TRUE, size=TRUE, edge = NULL) get_sdm(object, ...) # S3 method for edma_sdm get_sdm(object, sort=FALSE,     level = 0.95, ...)  # S3 method for edma_sdm print(x, level = 0.95, ...) Z_test(object, ...) # S3 method for edma_sdm Z_test(object, level = 0.95, ...) # S3 method for edma_sdm landmarks(x, ...) # S3 method for edma_sdm dimensions(x, ...)  # S3 method for edma_sdm confint(object, parm, level=0.95, ...) # S3 method for edma_sdm get_influence(object, statistic=c(\"Z\", \"C\"),     level=0.95, ...)  plot_Ztest(x, ...) # S3 method for edma_sdm plot_Ztest(x, statistic=c(\"Z\", \"C\"),     level = 0.95, ...)"},{"path":"/reference/edma_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shape difference — edma_sdm","text":", b EDMA fit object compare shapes. x, object SDM object. log logical, form matrix log transformed calculating differences. size logical, size difference (C) estimated (TRUE) fixed 1 (FALSE). edge numeric character, numeric IDs name 2 landmarks used calculate C (C=db/da, da db edge distances two landmarks object b respectively). C calculated using total least squares (TLS) edge=NULL. sort logical, stacked distances sorted, see Examples. level numeric, 0 1, alpha level confidence interval. parm specification parameters given confidence intervals, either vector numbers vector names. See confint. statistic character, Z C statistic plotted. ... arguments passed functions.","code":""},{"path":"/reference/edma_sdm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shape difference — edma_sdm","text":"Shape difference matrix (SDM) defined difference scaled form matrices S() S(B). S() = C * FM(), S(B) = FM(B), C scaling factor calculated using total least squares (TLS). Shape difference matrix S() - S(B) log=FALSE log(S()) - log(S(B)) log=TRUE. Inference visualization similar done FDMs. Note: original implementation usinga particular edge calculate size (C) parameter (size=TRUE edge NULL). edge=NULL uses total least squares estimate C based edges landmarks. size=FALSE set C=1, assuming sizez .","code":""},{"path":"/reference/edma_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shape difference — edma_sdm","text":"edma_sdm compares 2 EDMA fit objects calculates SDM.","code":""},{"path":"/reference/edma_sdm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shape difference — edma_sdm","text":"Lele, S. R., Cole, T. M. III., 1996. new test shape differences variance-covariance matrices unequal. Journal Human Evolution 31:193--212. <doi:10.1006/jhev.1996.0057>","code":""},{"path":"/reference/edma_sdm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Shape difference — edma_sdm","text":"Peter Solymos, Subhash R. Lele, Theodore M. Cole","code":""},{"path":[]},{"path":"/reference/edmainr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Euclidean Distance Matrix Analysis in R — EDMAinR-package","title":"Euclidean Distance Matrix Analysis in R — EDMAinR-package","text":"coordinate-free approach comparing      biological shapes using landmark data based     Lele Richtsmeier (1991) <doi:10.1002/ajpa.1330860307>.","code":""},{"path":"/reference/edmainr-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Euclidean Distance Matrix Analysis in R — EDMAinR-package","text":"EDMA data: read_xyz Nonparametric fit: edma_fit Form difference: edma_fdm Growth growth difference: edma_gm, edma_gdm Shape difference: edma_sdm","code":""},{"path":"/reference/edmainr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Euclidean Distance Matrix Analysis in R — EDMAinR-package","text":"NA Maintainer: NA","code":""},{"path":"/reference/edmainr-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Euclidean Distance Matrix Analysis in R — EDMAinR-package","text":"Lele, S. R., 1991. comments coordinate-free scale-invariant methods morphometrics. American Journal Physical Anthropology 85:407--417. <doi:10.1002/ajpa.1330850405> Lele, S. R., Richtsmeier, J. T., 1991. Euclidean distance matrix analysis: coordinate-free approach comparing biological shapes using landmark data. American Journal Physical Anthropology 86(3):415--27. <doi:10.1002/ajpa.1330860307> Lele, S. R., Richtsmeier, J. T., 1992. comparing biological shapes: detection influential landmarks. American Journal Physical Anthropology 87:49--65. <doi:10.1002/ajpa.1330870106> Lele, S. R., Richtsmeier, J. T., 1995. Euclidean distance matrix analysis: confidence intervals form growth differences. American Journal Physical Anthropology 98:73--86. <doi:10.1002/ajpa.1330980107> Hu, L., 2007. Euclidean Distance Matrix Analysis Landmarks Data: Estimation Variance. Thesis, Master Science Statistics, Department Mathematical Statistical Sciences, University Alberta, Edmonton, Alberta, Canada. Pp. 49. Lele, S. R., Cole, T. M. III., 1996. new test shape differences variance-covariance matrices unequal. Journal Human Evolution 31:193--212. <doi:10.1006/jhev.1996.0057>","code":""},{"path":"/reference/gpa_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"GPA — gpa_fit","title":"GPA — gpa_fit","text":"Fit GPA WGPA landmark data.","code":""},{"path":"/reference/gpa_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"GPA — gpa_fit","text":"","code":"gpa_fit(x, B = 0, ncores = getOption(\"Ncpus\", 1L),     weighted=FALSE, ...) # S3 method for gpa_fit print(x, truncate=40, ...)"},{"path":"/reference/gpa_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GPA — gpa_fit","text":"x EDMA data object class 'edma_data'. B nonnegative integer, number bootstrap replicates. weighted logical, use shapes::procWGPA instead shapes::procGPA. ncores positive integer, number cores use bootstrapping. Use options(Ncpus = 2) set 2 globally. truncate numeric, number characters print object title. ... arguments passed shapes::procGPA shapes::procWGPA.","code":""},{"path":"/reference/gpa_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GPA — gpa_fit","text":"Returns form matrix, SigmaKstar NA.","code":""},{"path":"/reference/gpa_fit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"GPA — gpa_fit","text":"Gower, J.C. (1975). Generalized Procrustes analysis, Psychometrika, 40, 33--50.","code":""},{"path":"/reference/gpa_fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"GPA — gpa_fit","text":"Peter Solymos wrote wrapper shapes::procGPA.","code":""},{"path":"/reference/internals.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — internals","title":"Internal functions — internals","text":"Users avoid directly using functions. part public user interface can changed time without warning.","code":""},{"path":"/reference/internals.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — internals","text":"","code":".edma_fit_np(A, less=TRUE) .Ttest_data(d1, d2, ref_denom=TRUE, mix=FALSE) .gpa_fit(A, ..., weighted=FALSE, gpa_results=FALSE)"},{"path":"/reference/internals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — internals","text":"landmark data array (.e. .array(x)). weighted use shapes::procWGPA instead shapes::procGPA. gpa_results return GPA results. less logical argument controlling function returns. d1, d2 EDMA fit object compare forms. ref_denom logical, TRUE, denominator used reference object (form matrix fixed calculating bootstrap comparing object). mix logical, use mixed bootstrap (numeriator denominator populations mixed replacement) (non-reference population resampled replacement).","code":""},{"path":"/reference/report.html","id":null,"dir":"Reference","previous_headings":"","what":"EDMA Report — report","title":"EDMA Report — report","text":"Writes output text file following close WinEDMA implementation.","code":""},{"path":"/reference/report.html","id":null,"dir":"Reference","previous_headings":"","what":"Usage","title":"EDMA Report — report","text":"","code":"edma_fdm_report(numerator, denominator, output=\"edma_output.txt\",   landmarks=NULL, B=0, level=0.95, ref_denom=TRUE, mix=FALSE,   digits=4)  edma_gdm_report(numerator_yng, numerator_old,     denominator_yng, denominator_old, output=\"edma_output.txt\",     landmarks=NULL, B=0, level=0.95, ref_denom=TRUE, mix=FALSE,     digits=4)"},{"path":"/reference/report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EDMA Report — report","text":"numerator, denominator, numerator_yng, numerator_old, denominator_yng, denominator_old input file names EDMA data objects. output path file name output file. landmarks subset landmarks specified, NULL (use landmarks). B number bootstrap samples. level confidence level. ref_denom logical, TRUE, denominator used reference object (form matrix fixed calculating bootstrap comparing object). mix logical, use mixed bootstrap (numeriator denominator populations mixed replacement) (non-reference population resampled replacement). digits significant digits print.","code":""},{"path":"/news/index.html","id":"version-02-0-2021-11-04","dir":"Changelog","previous_headings":"","what":"Version 0.2-0, 2021-11-04","title":"Version 0.2-0, 2021-11-04","text":"Separate edma_fdm_report edma_gdm_report functions. Updated documentation.","code":""},{"path":"/news/index.html","id":"version-01-11-2021-08-17","dir":"Changelog","previous_headings":"","what":"Version 0.1-11, 2021-08-17","title":"Version 0.1-11, 2021-08-17","text":"Added edma_report() reproduce WinEDMA output. Fixed CI calculation: ref_denom argument flip numerator denominator. 2D 3D plot revised color edges label landmarks.","code":""},{"path":"/news/index.html","id":"version-01-10-2021-07-19","dir":"Changelog","previous_headings":"","what":"Version 0.1-10, 2021-07-19","title":"Version 0.1-10, 2021-07-19","text":"Bug fix: FDM methods issues B=0. Added landmark names 2D plots, use labels=TRUE. 3D plots now preserve XYZ aspect ration 1. signif_only=FALSE allows plotting top/bottom percentage linear distances (edges) 2D/3D plots.","code":""},{"path":"/news/index.html","id":"version-01-8-2020-12-19","dir":"Changelog","previous_headings":"","what":"Version 0.1-8, 2020-12-19","title":"Version 0.1-8, 2020-12-19","text":"Added new function gpa_fit estimate mean form based GPA.","code":""},{"path":"/news/index.html","id":"version-01-7-2020-11-27","dir":"Changelog","previous_headings":"","what":"Version 0.1-7, 2020-11-27","title":"Version 0.1-7, 2020-11-27","text":"Renaming T_* functions global_* avoid confusion T-test. Observed statistic included null distribution global testing. Added interactive plotly graphics vignettes.","code":""},{"path":"/news/index.html","id":"version-01-6-2020-11-20","dir":"Changelog","previous_headings":"","what":"Version 0.1-6, 2020-11-20","title":"Version 0.1-6, 2020-11-20","text":"Shape difference matrix (SDM) calculation added: edma_sdm. edma_sdm can set assume size, use TLS, particular edge. CI calculation (local FDM, GM, GDM, SDM testing) calculations use 2-sample bootstrap. Global FDM, GM, GDM testing (T-test) uses mixed reference bootstrap, global Z-test FDM based 2-sample bootstrap.","code":""},{"path":"/news/index.html","id":"version-01-4-2020-08-23","dir":"Changelog","previous_headings":"","what":"Version 0.1-4, 2020-08-23","title":"Version 0.1-4, 2020-08-23","text":".edma_fit_np preformant (original implementation retained .edma_fit_np_old comparison); also exposes mean/variance distances future uses. edma_simulate_data also much faster now. Nonparametric EDMA fid FDM analysis can use multiple cores. Added write.xyz function write EDMA data xyz format. Added 4 data sets growth difference analysis.","code":""},{"path":"/news/index.html","id":"version-01-3-2020-07-05","dir":"Changelog","previous_headings":"","what":"Version 0.1-3, 2020-07-05","title":"Version 0.1-3, 2020-07-05","text":"Small fixes parametric test helper functions. Miscellaneous function print/visualize pattern matrices. Exposed combine_data combine_data4 functions. Clustering method now can changed user. .edma_data method added turn 3D array (common morphometrics data format) EDMA data objects. Added edma_colors plot_edma_colors manipulating color palettes set via getOption(\"edma_options\"). Extensive updates docs vignettes.","code":""},{"path":"/news/index.html","id":"version-01-2-2020-04-30","dir":"Changelog","previous_headings":"","what":"Version 0.1-2, 2020-04-30","title":"Version 0.1-2, 2020-04-30","text":"Parametric estimation tested.","code":""},{"path":"/news/index.html","id":"version-01-1-2020-02-16","dir":"Changelog","previous_headings":"","what":"Version 0.1-1, 2020-02-16","title":"Version 0.1-1, 2020-02-16","text":"Global test p-values updated. Package website made {pkgdown}.","code":""},{"path":"/news/index.html","id":"version-01-0-2019-12-27","dir":"Changelog","previous_headings":"","what":"Version 0.1-0, 2019-12-27","title":"Version 0.1-0, 2019-12-27","text":"EDMA package command line interface finalized.","code":""}]
